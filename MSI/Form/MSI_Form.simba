//{$i MSI/MSI/Core/Setup.simba}

const
  IMG_COUNT = 12;
    IMG_BGND          = 0;
    IMG_X_NORM        = 1;
    IMG_Q_NORM        = 2;
    IMG_LOAD_TAB_NORM = 3;
    IMG_SAVE_TAB_NORM = 4;
    IMG_TAB_NORM_1    = 5;
    IMG_TAB_NORM_2    = 6;
    IMG_TAB_NORM_3    = 7;
    IMG_TAB_NORM_4    = 8;
    IMG_TAB_NORM_5    = 9;
    IMG_TAB_NORM_0    = 10;
    IMG_RUN_NORM      = 11;

    PANEL_COUNT = 6;

  BITMAP_COUNT = 25;
    BGND            = 0;
    X_NORM          = 1;
    X_HOVER         = 2;
    Q_NORM          = 3;
    Q_HOVER         = 4;
    LOAD_TAB_NORM   = 5;
    LOAD_TAB_HOVER  = 6;
    SAVE_TAB_NORM   = 7;
    SAVE_TAB_HOVER  = 8;
    TAB_NORM_1      = 9;
    TAB_HOVER_1     = 10;
    TAB_NORM_2      = 11;
    TAB_HOVER_2     = 12;
    TAB_NORM_3      = 13;
    TAB_HOVER_3     = 14;
    TAB_NORM_4      = 15;
    TAB_HOVER_4     = 16;
    TAB_NORM_5      = 17;
    TAB_HOVER_5     = 18;
    TAB_NORM_0      = 19;
    TAB_HOVER_0     = 20;
    BGND_PANEL      = 21;
    RUN_NORM        = 22;
    RUN_HOVER       = 23;
    SCRIPT_BGND     = 24;

// Form components
var
  MainForm: TForm;
  AnimTimer: TTimer;

  tImages: array[0..IMG_COUNT - 1] of TImage;
  frmBitmaps: array [0..BITMAP_COUNT - 1] of Integer;
  isActiveImage: array[0..IMG_COUNT - 1] of Boolean;
  isLeftTab: array[IMG_TAB_NORM_1..IMG_TAB_NORM_5] of Boolean;
  panels: array [IMG_TAB_NORM_1..IMG_TAB_NORM_1 + PANEL_COUNT - 1] of TPanel;

var
  pBoxIndex: Integer; // Stores the index of the player displayed in the combo boxes relative to the combo box, not the MSI_Players array
  ScriptReady: Boolean;

var // All Panels
  Previous, Next: array [IMG_TAB_NORM_2..IMG_TAB_NORM_5] of TButton;
  ChoosePlay: array [IMG_TAB_NORM_2..IMG_TAB_NORM_5] of TCombobox;

var // Panel 1: Player Management
  checkList_Players: TCheckListBox;
  edit_User, edit_Pass, edit_Pin, edit_CurPlayer: TEdit;
  comboBox_Member: TComboBox;
  btn_AddPlayer, btn_DeletePlayer: TButton;
  panOne_Inst, label_Username, label_Pass, label_Pin, label_Member, label_CurPlayer: TLabel;

var // Panel 2: Script Choosing
  CheckListBox_3: TCheckListBox;
  inst_P3: TLabel;

var // Panel 3: Location Setting
  CheckListBox_4: TCheckListBox;
  inst_P4: TLabel;

var // Panel 4: Set Other Player Options
  inst_P5, timeTotal, timeBreak, loadsBreak, loadsTotal: TLabel;
  time_Total_5, time_Break_5, loads_Break_5, loads_Total_5: TEdit;

var // Panel 5: Script Setup
  five_Labels: array[0..2] of TLabel;
  ComboBox_Script_6: TComboBox;
  nScript, pScript: TButton;

(**
 * Converts a string to an integer array; for example,
 * StrToIntArr('1,2,3,4') will result [1, 2, 3, 4]
 *)

var
  FixErrors: Boolean;

function StrToIntArr(Str: string): TIntegerArray;
var
  i, j: Integer;
  s: TStringArray;
begin
  if (Str = '') then
    Exit;

  s := Explode(',', Str);

  setLength(Result, Length(s));
  for i := 0 to High(s) do
    try
      Result[j] := StrToIntDef(s[i], -MaxInt)
      if (Result[j] = -MaxInt) then
        dec(j); // force j to be the old index
      inc(j);
    except
      Writeln('Invalid integer!');
    end;

  setLength(Result, j);
end;

(**
 * Converts an integer array to a string; for example,
 * IntArrToStr(['1, 2, 3, 4']) will result '1,2,3,4'
 *)
function IntArrToStr(Int: TIntegerArray): string;
var
  i, h: Integer;
begin
  if (Length(Int) <= 0) then
  begin
    Result := '';
    Exit;
  end;

  h := High(int);
  for i := 0 to h do
    if (i = h) then
      Result := Result + IntToStr(Int[i])
    else
      Result := Result + IntToStr(Int[i]) + ',';

  //Writeln(Result);
end;

function GetObjByName(name: string): TMSObject;
var
  i: integer;
  obj: TMSObject;
begin
  for i := 0 to OBJECT_HIGH do
  begin
    obj := MSI_GetObject(i);
    if (obj.name = '') then
      continue;

    if (uppercase(obj.name) = uppercase(name)) then
    begin
      result := obj;
      break;
    end;
  end;
end;

// Get the player index from the player's name
function GetPlayerIndex(Username: string): Integer;
var
  i: Integer;
begin
  if (Username = '') then
  begin
    Result := -1;
    Exit;
  end;

  for i := 0 to High(MSI_Players) do
    if (Lowercase(MSI_Players[i].Name) = Lowercase(Username)) then
    begin
      Result := i;
      Exit;
    end;
end;

function MSI_GetObjByName(name: string): TMSObject;
var
  i: integer;
  obj: TMSObject;
begin
  for i := 0 to OBJECT_HIGH do
  begin
    obj := MSI_GetObject(i);
    if (obj.name = '') then
      continue;

    if (uppercase(obj.name) = uppercase(name)) then
    begin
      result := obj;
      break;
    end;
  end;
end;

// Prevents people from typing in combo boxes
procedure PreventTyping(Sender: TObject; var Key: Char);
begin
  Key := Chr(VK_CANCEL);
end;

var // Intro Panel
  intro_Inst, intro_Next: TLabel;

  intro_Combos: array of TComboBox;
  intro_Edits: array of TEdit;
  intro_ComboLabels, intro_EditLabels: array of TLabel;
  s: TStringArray;

var
  MouseDown: Boolean;  // Is the mouse down?
  cPoint: TPoint;  // Mouse cursor position at time of mouse down.

procedure BGMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if(Button <> mbLeft) then
    Exit;

  MouseDown := True;
  cPoint := Point(X, Y);
end;

procedure BGMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if(Button <> mbLeft) then
    Exit;

  MouseDown := False;
end;

procedure intro_CreateComponents();
var
  i, j: Integer;
begin
  intro_Inst := TLabel.Create(panels[IMG_TAB_NORM_0]);
  with intro_Inst do
  begin
    Parent := panels[IMG_TAB_NORM_0];
    SetBounds(70, 5, 100, 25);
    Caption := 'Setup all the different script properties';
    Font.Color := 2070783;
  end;

  intro_Next := TLabel.Create(panels[IMG_TAB_NORM_0]);
  with intro_Next do
  begin
    Parent := panels[IMG_TAB_NORM_0];
    SetBounds(25, 268, 100, 25);
    Caption := 'Click the sliding panels to reveal player setup steps >>';
    Font.Color := 2070783;
  end;

  for i := 0 to High(MSI_Settings) do
  begin
    case i of
      SETUP_DEBUG_SMART, SETUP_SAVE_DEBUG, SETUP_SAVE_REPORT, SETUP_HUMAN_BREAK,
      SETUP_SWITCH_WORLDS, SETUP_QC_LEVELUP:
        begin
          SetLength(intro_Combos, Length(intro_Combos) + 1);

          intro_Combos[High(intro_Combos)] := TComboBox.Create(panels[IMG_TAB_NORM_0]);
          with intro_Combos[High(intro_Combos)] do
          begin
            Parent := panels[IMG_TAB_NORM_0];
            Text := 'True';
            Items.Add('True');
            Items.Add('False');
            OnKeyPress := @PreventTyping;

            for j := 0 to High(intro_Combos) do
              SetBounds(95, 27 + (j * 35), 70, 20);

            case i of
              SETUP_DEBUG_SMART: Hint := 'Shows debugging on the main screen';
              SETUP_SAVE_DEBUG: Hint := 'Saves debug logs to a file';
              SETUP_SAVE_REPORT: Hint := 'Saves the progress report to a file';
              SETUP_HUMAN_BREAK: Hint := 'Will randomly logout, time-out, or exit to the lobby if set to True, '+#10+
                                         'otherwise will just exit to the lobby.';
              SETUP_SWITCH_WORLDS: Hint := 'Will switch worlds after breaking and when switching players';
              SETUP_QC_LEVELUP: Hint := 'Do you want to quick-chat your level when your player gains a level?';
            end;

            ShowHint := True;
          end;
        end;

      SETUP_BREAK_TIME, SETUP_DEBUG_LEVEL, SETUP_ANTIBAN_WAIT, SETUP_RANDOMS_WAIT,
      SETUP_STATS_ID, SETUP_STATS_PASS, SETUP_MAX_PLAYERS:
        begin
          SetLength(intro_Edits, Length(intro_Edits) + 1);

          intro_Edits[High(intro_Edits)] := TEdit.Create(panels[IMG_TAB_NORM_0]);
          with intro_Edits[High(intro_Edits)] do
          begin
            Parent := panels[IMG_TAB_NORM_0];

            for j := 0 to High(intro_Edits) do
              SetBounds(257, 27 + (j * 35), 65, 20);

            case i of
              SETUP_BREAK_TIME:
                begin
                  Hint := 'Single player only: How long to break for (in minutes)';
                  Text := '15';
                end;

              SETUP_DEBUG_LEVEL:
                begin
                  Hint := 'The lower the number, the less MSI will debug';
                  Text := '10';
                end;

              SETUP_ANTIBAN_WAIT:
                begin
                  Hint := 'How long to wait between Antiban calls (in milliseconds; 1s = 1000ms)';
                  Text := '15000';
                end;

              SETUP_RANDOMS_WAIT:
                begin
                  Hint := 'How long to wait between Randoms checks (in milliseconds; 1s = 1000ms)';
                  Text := '15000';
                end;

              SETUP_MAX_PLAYERS:
                begin
                  Hint := 'How many players can be around you before switching worlds.  Set to 0 to not switch worlds.';
                  Text := '30';
                end;

              SETUP_STATS_ID: Hint := 'Stats Username';
              SETUP_STATS_PASS: Hint := 'Stats Password';
            end;

            ShowHint := True;
          end;
        end;
    end;
  end;

  SetLength(intro_EditLabels, Length(intro_Edits));
  s := ['Break Time', 'Level to Debug', 'Antiban Wait', 'Randoms Wait',
        'Max Players', 'Stats User', 'Stats Pass'];
  for i := 0 to High(intro_EditLabels) do
  begin
    intro_EditLabels[i] := TLabel.Create(panels[IMG_TAB_NORM_0]);
    with intro_EditLabels[i] do
    begin
      Parent := panels[IMG_TAB_NORM_0];
      Caption := s[i];
      Font.Color := 2070783;
      Font.Size := 8;
      SetBounds(intro_Edits[i].Left - (intro_Edits[i].Width + 16), intro_Edits[i].Top + 4, 50, 25);
    end;
  end;

  SetLength(intro_ComboLabels, Length(intro_Combos));
  s := ['Debug SMART', 'Save Debug', 'Save Report', 'Human Breaking',
        'Switch Worlds','QC Level Up', 'Walking Method' ];
  for i := 0 to High(intro_ComboLabels) do
  begin
    intro_ComboLabels[i] := TLabel.Create(panels[IMG_TAB_NORM_0]);
    with intro_ComboLabels[i] do
    begin
      Parent := panels[IMG_TAB_NORM_0];
      Caption := s[i];
      Font.Color := 2070783;
      Font.Size := 8;
      SetBounds(intro_Combos[i].Left - (intro_Combos[i].Width + 25), intro_Combos[i].Top + 4, 50, 25);
    end;
  end;

end;

procedure intro_Settings(Save: Boolean);
var
  i, j: Integer;
  s: string;
begin
  for i := 0 to High(MSI_Settings) do
    case i of
      SETUP_DEBUG_SMART, SETUP_SAVE_DEBUG, SETUP_SAVE_REPORT, SETUP_HUMAN_BREAK, SETUP_SWITCH_WORLDS,
      SETUP_QC_LEVELUP:
        begin
          case i of
            SETUP_DEBUG_SMART: s := 'Debug SMART';
            SETUP_SAVE_DEBUG: s := 'Save Debug';
            SETUP_SAVE_REPORT: s := 'Save Report';
            SETUP_HUMAN_BREAK: s := 'Human Breaking';
            SETUP_SWITCH_WORLDS: s := 'Switch Worlds';
            SETUP_QC_LEVELUP: s := 'QC Level Up';
          end;

          for j := 0 to High(intro_ComboLabels) do
            if (intro_ComboLabels[j].Caption = s) then
              if (Save) then
              begin
                if (intro_Combos[j].Text = '') then
                begin
                  if (s = 'Walking Method') then
                    WriteINI('SETTINGS', s, 'Color', PATH_SETTINGS)
                  else
                    WriteINI('SETTINGS', s, 'True', PATH_SETTINGS);

                  MSI_Settings[i] := True;
                end else begin
                  WriteINI('SETTINGS', s, intro_Combos[j].Text, PATH_SETTINGS);

                  if (s = 'Walking Method') then
                    MSI_Settings[i] := intro_Combos[j].Text
                  else
                    MSI_Settings[i] := StrToBool(intro_Combos[j].Text);
                end;

                //Writeln('SetupVar['+IntToStr(i)+'] := '+ToStr(MSI_Settings[i]));
              end else
                if (FileExists(PATH_SETTINGS)) then
                  intro_Combos[j].Text := ReadINI('SETTINGS', s, PATH_SETTINGS);
        end;

      SETUP_BREAK_TIME, SETUP_DEBUG_LEVEL, SETUP_ANTIBAN_WAIT, SETUP_RANDOMS_WAIT,
      SETUP_STATS_ID, SETUP_STATS_PASS, SETUP_MAX_PLAYERS:
        begin
          case i of
            SETUP_BREAK_TIME: s := 'Break Time';
            SETUP_DEBUG_LEVEL: s := 'Level to Debug';
            SETUP_ANTIBAN_WAIT: s := 'Antiban Wait';
            SETUP_RANDOMS_WAIT: s := 'Randoms Wait';
            SETUP_STATS_ID: s := 'Stats User';
            SETUP_STATS_PASS: s := 'Stats Pass';
            SETUP_MAX_PLAYERS: s := 'Max Players';
          end;

          for j := 0 to High(intro_EditLabels) do
            if (intro_EditLabels[j].Caption = s) then
              if (Save) then
              begin
                if (i = SETUP_STATS_ID) or (i = SETUP_STATS_PASS) then
                begin
                  WriteINI('SETTINGS', s, intro_Edits[j].Text, PATH_SETTINGS);
                  MSI_Settings[i] := intro_Edits[j].Text;
                end else
                  if (StrToIntDef(intro_Edits[j].Text, -1) = -1) then
                  begin
                    ShowMessage(intro_EditLabels[j].Caption + ' must be an number!');
                    Exit;
                  end else begin
                    MSI_Settings[i] := StrToInt(intro_Edits[j].Text);
                    WriteINI('SETTINGS', s, intro_Edits[j].Text, PATH_SETTINGS);
                  end;

                //Writeln('SetupVar['+IntToStr(i)+'] := '+ToStr(MSI_Settings[i]));
              end else
                if (FileExists(PATH_SETTINGS)) then
                  intro_Edits[j].Text := ReadINI('SETTINGS', s, PATH_SETTINGS);

        end;
    end;
end;

(*
   SCRIPT SETUP COMPONENTS & OTHER
   ===============================

   Written by: Coh3n
*)

(**
 * Used to for TScriptSetup for each player
 *)
const
  LIST_COUNT = 9;
    LIST_ROCKS     = 0;
    LIST_TREES     = 1;
    LIST_FISHSPOTS = 2;
    LIST_SPELLS    = 3;
    LIST_STAFFS    = 4;
    LIST_DROP      = 5;
    LIST_MATERIALS = 6;
    LIST_COOKSPOTS = 7;
    LIST_OBJECTS   = 8;

  EDIT_COUNT = 7;
    EDIT_LOADS      = 0;
    EDIT_TIME       = 1;
    EDIT_LEVEL      = 2;
    EDIT_EXCEPTIONS = 3;
    EDIT_ALCH_SLOTS = 4;
    EDIT_PRIORITY   = 6;
    EDIT_HEAT_SLOTS = 5;

  COMBO_COUNT = 1;
    COMBO_COALBAG = 0;

var
  script_Form: TForm;
  script_BackgroundImage: TImage;
  script_ListTexts, script_EditTexts, script_ComboTexts: TStringArray;
  script_Buttons: array[0..1] of TButton;
  script_Lists: array[0..LIST_COUNT - 1] of TCheckListBox;
  script_ListLabels: array[0..LIST_COUNT - 1] of TLabel;
  script_Edits: array[0..EDIT_COUNT - 1] of TEdit;
  script_EditLabels: array[0..EDIT_COUNT - 1] of TLabel;
  script_Combos: array[0..COMBO_COUNT - 1] of TComboBox;
  script_ComboLabels: array[0..COMBO_COUNT - 1] of TLabel;

procedure script_HideComponents();
var
  i: integer;
begin
  for i := 0 to High(script_Edits) do
    script_Edits[i].Visible := False;

  for i := 0 to High(script_Combos) do
    script_Combos[i].Visible := False;

  for i := 0 to High(script_ListLabels) do
    script_ListLabels[i].Visible := False;

  for i := 0 to High(script_EditLabels) do
    script_EditLabels[i].Visible := False;

  for i := 0 to High(script_ComboLabels) do
    script_ComboLabels[i].Visible := False;
end;

procedure script_ShowComponents();
var
  i, j: Integer;
  default, lists, edits, items, objs, combos: TIntegerArray;
  obj: TMSObject;
begin
  script_HideComponents();

  for i := 0 to High(MSI_Scripts) do
    if (MSI_Scripts[i].Name = comboBox_Script_6.Text) then
    begin
      case MSI_Scripts[i].SkillConst of
        SKILL_WOODCUTTING, SKILL_MINING, SKILL_FISHING:
          begin
            case MSI_Scripts[i].SkillConst of
              SKILL_WOODCUTTING:
                begin
                  lists := [LIST_TREES, LIST_DROP];
                  default := MSI_Scripts[i].Defaults.Trees;
                  items := [MISC_BIRD_NEST];
                end;

              SKILL_MINING:
                begin
                  lists :=[LIST_ROCKS, LIST_DROP];
                  default := MSI_Scripts[i].Defaults.Rocks;
                  items := [GEM_UNCUT_SAPPHIRE, GEM_UNCUT_EMERALD, GEM_UNCUT_RUBY, GEM_UNCUT_DIAMOND];
                  combos := [COMBO_COALBAG];
                end;

              SKILL_FISHING:
                begin
                  lists :=[LIST_FISHSPOTS];
                  default := MSI_Scripts[i].Defaults.FishSpots;
                end;
            end;

            script_Lists[lists[0]].CLEAR;
            script_Lists[LIST_DROP].CLEAR;

            // Add the default objects to the TCheckListBox
            for j := 0 to High(default) do
            begin
              obj := MSI_GetObject(default[j]);
              script_Lists[lists[0]].items.append(obj.name);
            end;

            // Add the items to the don't drop/bank TCheckListBox
            for j := 0 to High(items) do
              script_Lists[LIST_DROP].Items.Append(MSI_Items[items[j]].Name);

            // Lists and edits for Woodcutting, Mining and Woodcutting
            edits := [EDIT_LOADS, EDIT_TIME, EDIT_LEVEL, EDIT_EXCEPTIONS, EDIT_PRIORITY];
          end;

        SKILL_COOKING, SKILL_NONE:
          begin
            script_Lists[LIST_MATERIALS].CLEAR;

            case MSI_Scripts[i].SkillConst of
              SKILL_NONE:
                begin
                  script_Lists[LIST_OBJECTS].CLEAR;
                  lists := [LIST_MATERIALS, LIST_OBJECTS];
                  edits := [EDIT_TIME, EDIT_LOADS];
                  objs := msi_scripts[i].defaults.objects;
                end;

              SKILL_COOKING:
                begin
                  script_lists[LIST_COOKSPOTS].CLEAR;
                  lists := [LIST_COOKSPOTS, LIST_MATERIALS];
                  edits := [EDIT_LOADS, EDIT_TIME, EDIT_LEVEL];
                  objs := msi_scripts[i].defaults.CookingSpot;
                end;
            end;

            // add cooking spots
            for j := 0 to high(objs) do
            begin
              obj := MSI_GetObject(objs[j]);
              case MSI_Scripts[i].SkillConst of
                SKILL_COOKING:
                  script_lists[LIST_COOKSPOTS].items.append(obj.name);

                SKILL_NONE:
                  script_lists[LIST_OBJECTS].items.append(obj.name);
              end;
            end;

            // add materials
            for j := 0 to high(msi_scripts[i].defaults.materials) do
              script_lists[LIST_MATERIALS].ITEMS.Append(MSI_GetMaterial(msi_scripts[i].defaults.materials[j]).name);
          end;

        SKILL_MAGIC:
          begin
            // Sets up spells if not already done so
            if (not SpellSetup) then
              SetupSpells;

            script_Lists[LIST_SPELLS].CLEAR;
            script_Lists[LIST_STAFFS].CLEAR;

            // Adds all the spells to the Spells list
            for j := 0 to High(MSI_Scripts[i].Defaults.Spells) do
              script_Lists[LIST_SPELLS].Items.Append(MSI_Spells[MSI_Scripts[i].Defaults.Spells[j]].Name);

            // Adds all the staffs to the Staff list
            for j := 0 to High(MSI_Items) do
              if (Pos('staff', Lowercase(MSI_Items[j].Name)) > 0) then
                script_Lists[LIST_STAFFS].Items.Append(Capitalize(MSI_Items[j].Name));

            lists := [LIST_SPELLS, LIST_STAFFS];

            if (MSI_Scripts[i].Constant = SCRIPT_ALCHER) then
              edits := [EDIT_TIME, EDIT_LEVEL, EDIT_ALCH_SLOTS]
            else
              Edits := [EDIT_TIME, EDIT_LEVEL];

             if (MSI_Scripts[i].Constant = SCRIPT_SUPERHEATER) then
              edits := [EDIT_TIME, EDIT_LEVEL, EDIT_HEAT_SLOTS]
            else
              Edits := [EDIT_TIME, EDIT_LEVEL];

          end;

        SKILL_RUNECRAFTING:
          begin
            edits := [EDIT_LOADS, EDIT_TIME, EDIT_LEVEL];
          end;
      end;

      // Make lists visible
      for j := 0 to High(lists) do
      begin
        script_Lists[lists[j]].Visible := True;
        script_ListLabels[lists[j]].Visible := True;
      end;

      // Make edit boxes visible
      for j := 0 to High(edits) do
      begin
        script_Edits[edits[j]].Top := (script_Lists[0].Top + (35 * j));
        script_Edits[edits[j]].Visible := True;

        script_EditLabels[edits[j]].Top := script_Edits[edits[j]].Top + 5;
        script_EditLabels[edits[j]].Visible := True;
      end;

      for j := 0 to high(combos) do
      begin
        script_Combos[combos[j]].visible := True;
        script_ComboLabels[combos[j]].visible := True;
      end;
    end;
end;

procedure script_FillComponents(pIndex: Integer); // OnChange
var
  i, j, lIndex, sIndex, skill: Integer;
  objects: TIntegerArray;
  m: TMaterial;
  obj: TMSObject;
begin
  for i := 0 to High(MSI_Scripts) do
    if (comboBox_Script_6.Text = MSI_Scripts[i].Name) then
    begin
      sIndex := comboBox_Script_6.ITEMS.IndexOf(comboBox_Script_6.Text);
      skill := MSI_Scripts[i].SkillConst;
      //Writeln('Skill: '+MSI_Scripts[i].SkillName);
      Break;
    end;

  //Writeln('Script Index: '+IntToStr(sIndex));

  case skill of
    SKILL_WOODCUTTING, SKILL_MINING, SKILL_FISHING:
      begin
        case skill of
          SKILL_WOODCUTTING:
            begin
              lIndex := LIST_TREES;
              objects := MSI_Players[pIndex].Scripts[sIndex].Trees;
            end;

          SKILL_MINING:
            begin
              lIndex := LIST_ROCKS;
              objects := MSI_Players[pIndex].Scripts[sIndex].Rocks;
            end;

          SKILL_FISHING:
            begin
              lIndex := LIST_FISHSPOTS;
              objects := MSI_Players[pIndex].Scripts[sIndex].FishSpots;
            end;
        end;

        // Check off the objects in the list
        //Writeln(ToStr(objects));
        for i := 0 to High(objects) do
        begin
          obj := MSI_GetObject(objects[i]);
          for j := 0 to (script_Lists[lIndex].items.count - 1) do
            if (uppercase(script_Lists[lIndex].items.strings[j]) = uppercase(obj.name)) then
              script_Lists[lIndex].checked[j] := true;
        end;

        // Check off all the dont drop items
        for i := 0 to High(MSI_Players[pIndex].Scripts[sIndex].DontDrop) do
          for j := 0 to (script_Lists[LIST_DROP].Items.Count - 1) do
            if (Lowercase(script_Lists[LIST_DROP].Items.Strings[j]) = Lowercase(MSI_Items[MSI_Players[pIndex].Scripts[sIndex].DontDrop[i]].Name)) then
              script_Lists[LIST_DROP].Checked[j] := True;

        with MSI_Players[pIndex].Scripts[sIndex] do
        begin
          //script_Edits[EDIT_LOADS].Text := IntToStr(Loads);
          script_Edits[EDIT_LOADS].Text := intToStr(Loads);
          script_Edits[EDIT_PRIORITY].Text := IntArrToStr(Priority);
          script_Edits[EDIT_EXCEPTIONS].Text := IntArrToStr(Exceptions);
        end;
      end;

    SKILL_COOKING, SKILL_NONE:
      begin
        if (skill = SKILL_COOKING) then
          for i := 0 to High(msi_players[pIndex].scripts[sIndex].CookingSpot) do
          begin
            obj := MSI_GetObject(msi_players[pIndex].scripts[sIndex].CookingSpot[i]);
            for j := 0 to (script_Lists[LIST_COOKSPOTS].Items.Count - 1) do
              if (uppercase(script_Lists[LIST_COOKSPOTS].Items.Strings[j]) = uppercase(obj.name)) then
                script_Lists[LIST_COOKSPOTS].Checked[j] := true;
          end;

        for i := 0 to High(msi_players[pIndex].scripts[sIndex].materials) do
          for j := 0 to (script_Lists[LIST_MATERIALS].Items.Count - 1) do
          begin
            m := MSI_GetMaterial(msi_players[pIndex].scripts[sIndex].materials[i]);
            if (Lowercase(script_Lists[LIST_MATERIALS].Items.Strings[j]) = Lowercase(m.Name)) then
              script_Lists[LIST_MATERIALS].Checked[j] := true;
          end;

        with MSI_Players[pIndex].Scripts[sIndex] do
        begin
          script_Edits[EDIT_LOADS].Text := intToStr(Loads);
        end;
      end;

    SKILL_MAGIC:
      begin
        if (not SpellSetup) then
          SetupSpells;

        with MSI_Players[pIndex].Scripts[sIndex] do
        begin
          // Check off all the spells
          for i := 0 to High(Spells) do
            for j := 0 to (script_Lists[LIST_SPELLS].ITEMS.Count - 1) do
              if (Lowercase(MSI_Spells[Spells[i]].Name) = Lowercase(script_Lists[LIST_SPELLS].ITEMS.Strings[j])) then
                script_Lists[LIST_SPELLS].Checked[j] := True;

          // Check off all the staffs
          for i := 0 to High(Staffs) do
            for j := 0 to (script_Lists[LIST_STAFFS].ITEMS.Count - 1) do
              if (Lowercase(MSI_Items[Staffs[i]].Name) = Lowercase(script_Lists[LIST_STAFFS].ITEMS.Strings[j])) then
                script_Lists[LIST_STAFFS].Checked[j] := True;

          // Fill the AlchSlots edit
          script_Edits[EDIT_ALCH_SLOTS].Text := IntArrToStr(MSI_Players[pIndex].Scripts[sIndex].AlchSlots);

          // Fill the HeatSlots edit
          script_Edits[EDIT_HEAT_SLOTS].Text := IntArrToStr(MSI_Players[pIndex].Scripts[sIndex].HeatSlots);
        end;
      end;
  end;

  // Time is common for every script
  with MSI_Players[pIndex].Scripts[sIndex] do
  begin
    script_Edits[EDIT_LEVEL].Text := IntToStr(MaxLevel);
    script_Edits[EDIT_TIME].Text := IntToStr(Time);
  end;

  //Writeln('Filled Script Setup Components');
end;

procedure script_FillCombo();
var
  i, pIndex: Integer;
begin
  comboBox_Script_6.CLEAR;

  pIndex := GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_5].Text);

  with MSI_Players[pIndex] do
    for i := 0 to High(Scripts) do
      comboBox_Script_6.Items.Append(MSI_Scripts[Scripts[i].Name].Name);
end;

(**
 * Currently sets:
 *
 *)
procedure script_SetInfo(pIndex, sIndex: Integer);
var
  i, j, skill, lIndex: Integer;
  m: TMaterial;
  obj: TMSObject;
begin
  if (pIndex <= -1) or (sIndex <= -1) then
    Exit;

  for i := 0 to High(MSI_Scripts) do
    if (comboBox_Script_6.Items.Strings[sIndex] = MSI_Scripts[i].Name) then
    begin
      //Writeln('Script Index: '+IntToStr(sIndex));
      skill := MSI_Scripts[i].SkillConst;
      Break;
    end;

  //Writeln('Player Index: '+IntToStr(pIndex));

  case skill of
    SKILL_WOODCUTTING, SKILL_MINING, SKILL_FISHING:
      begin
        case skill of
          SKILL_WOODCUTTING:
            lIndex := LIST_TREES;

          SKILL_MINING:
            lIndex := LIST_ROCKS;

          SKILL_FISHING:
            lIndex := LIST_FISHSPOTS;
        end;

        SetLength(MSI_Players[pIndex].Scripts[sIndex].Trees, 0);
        SetLength(MSI_Players[pIndex].Scripts[sIndex].Rocks, 0);
        SetLength(MSI_Players[pIndex].Scripts[sIndex].FishSpots, 0);

        // Set the Trees, Rocks, and FishSpots depending on the skill
        for i := 0 to script_Lists[lIndex].ITEMS.Count - 1 do
          if (script_Lists[lIndex].Checked[i]) then
          begin
            obj := MSI_GetObjByName(script_Lists[lIndex].Items.Strings[i]);
            case skill of
              SKILL_WOODCUTTING:
                with MSI_Players[pIndex].Scripts[sIndex] do
                begin
                  SetLength(Trees, Length(Trees) + 1);
                  Trees[High(Trees)] := obj.constant;
                  ClearSameIntegers(Trees);
                  //Writeln('Player '+IntToStr(pIndex)+' Trees: '+ToStr(Trees));
                end;

              SKILL_MINING:
                with MSI_Players[pIndex].Scripts[sIndex] do
                begin
                  SetLength(Rocks, Length(Rocks) + 1);
                  Rocks[High(Rocks)] := obj.constant;
                  ClearSameIntegers(Rocks);
                  //Writeln('Player '+IntToStr(pIndex)+' Rocks: '+ToStr(Rocks));
                end;

              SKILL_FISHING:
                with MSI_Players[pIndex].Scripts[sIndex] do
                begin
                  SetLength(FishSpots, Length(FishSpots) + 1);
                  FishSpots[High(FishSpots)] := obj.constant;
                  ClearSameIntegers(FishSpots);
                  //Writeln('Player '+IntToStr(pIndex)+' FishSpots: '+ToStr(FishSpots));
                end;
            end;
          end;

        SetLength(MSI_Players[pIndex].Scripts[sIndex].DontDrop, 0);

        // Set the items to exclude from dropping/banking
        for i := 0 to (script_Lists[LIST_DROP].ITEMS.Count - 1) do
          if (script_Lists[LIST_DROP].Checked[i]) then
            for j := 0 to High(MSI_Items) do
              if (Lowercase(script_Lists[LIST_DROP].Items.Strings[i]) = Lowercase(MSI_Items[j].Name)) then
                with MSI_Players[pIndex].Scripts[sIndex] do
                begin
                  SetLength(DontDrop, Length(DontDrop) + 1);
                  DontDrop[High(DontDrop)] := j;
                  ClearSameIntegers(DontDrop);
                end;

        // Set the other script information
        with MSI_Players[pIndex].Scripts[sIndex] do
        begin
          if (StrToIntDef(script_Edits[EDIT_LOADS].Text, -1) = -1) then
            ShowMessage('Invalid loads! Please enter a number.')
          else
            Loads := StrToInt(script_Edits[EDIT_LOADS].Text);

          try
            if (script_Edits[EDIT_EXCEPTIONS].Text = '') then
              Exceptions := []
            else
              Exceptions := StrToIntArr(script_Edits[EDIT_EXCEPTIONS].Text);

            ClearSameIntegers(Exceptions);
          except
            ShowMessage('Invalid exceptions input! Please enter in format: 1,2,3');
          end;

          try
            if (script_Edits[EDIT_PRIORITY].Text = '') then
              Priority := []
            else
              Priority := StrToIntArr(script_Edits[EDIT_PRIORITY].Text);

            ClearSameIntegers(Priority);
          except
            ShowMessage('Invalid priority input! Please enter in format: 60,20');
          end;

          if (StrToIntDef(script_Edits[EDIT_LEVEL].Text, -1) = -1) then
            ShowMessage('Invalid max level! Please enter a number.')
          else
            MaxLevel := StrToInt(script_Edits[EDIT_LEVEL].Text);

          try
            CoalBag := StrToBool(script_combos[COMBO_COALBAG].text);
          except
            ShowMessage('Invalid "Use Coal Bag" choice');
          end;
        end;
      end;

    SKILL_COOKING, SKILL_NONE:
      begin
        SetLength(MSI_Players[pIndex].Scripts[sIndex].materials, 0);

        if (skill = SKILL_COOKING) then
        begin
          for i := 0 to (script_Lists[LIST_COOKSPOTS].ITEMS.Count - 1) do
            if (script_Lists[LIST_COOKSPOTS].Checked[i]) then
            begin
              obj := GetObjByName(script_Lists[LIST_COOKSPOTS].Items.Strings[i]);
              with MSI_Players[pIndex].Scripts[sIndex] do
              begin
                SetLength(CookingSpot, Length(CookingSpot) + 1);
                CookingSpot[High(CookingSpot)] := obj.constant;
                ClearSameIntegers(CookingSpot);
              end;
            end;

          if (StrToIntDef(script_Edits[EDIT_LEVEL].Text, -1) = -1) then
            ShowMessage('Invalid max level! Please enter a number.')
          else
            MSI_Players[pIndex].Scripts[sIndex].MaxLevel := StrToInt(script_Edits[EDIT_LEVEL].Text);
        end else
          for i := 0 to (script_Lists[LIST_OBJECTS].ITEMS.Count - 1) do
            if (script_Lists[LIST_OBJECTS].Checked[i]) then
            begin
              obj := GetObjByName(script_Lists[LIST_OBJECTS].Items.Strings[i]);
              with MSI_Players[pIndex].Scripts[sIndex] do
              begin
                SetLength(Objects, Length(Objects) + 1);
                Objects[High(Objects)] := obj.constant;
                ClearSameIntegers(Objects);
              end;
            end;

        for i := 0 to script_Lists[LIST_MATERIALS].ITEMS.Count - 1 do
          if (script_Lists[LIST_MATERIALS].Checked[i]) then
            for j := 0 to MATERIAL_LENGTH do
            begin
              m := MSI_GetMaterial(j);
              if (Lowercase(m.Name) = Lowercase(script_Lists[LIST_MATERIALS].Items.Strings[i])) then
                with MSI_Players[pIndex].Scripts[sIndex] do
                begin
                  SetLength(materials, Length(materials) + 1);
                  materials[High(materials)] := j;
                  ClearSameIntegers(materials);
                  //Writeln('Player '+IntToStr(pIndex)+' materials: '+ToStr(materials));
                end;
            end;

        with MSI_Players[pIndex].Scripts[sIndex] do
        begin
          if (StrToIntDef(script_Edits[EDIT_LOADS].Text, -1) = -1) then
            ShowMessage('Invalid loads! Please enter a number.')
          else
            Loads := StrToInt(script_Edits[EDIT_LOADS].Text);
        end;
      end;

    SKILL_MAGIC:
      begin
        if (not SpellSetup) then
          SetupSpells;

        SetLength(MSI_Players[pIndex].Scripts[sIndex].Spells, 0);
        SetLength(MSI_Players[pIndex].Scripts[sIndex].Staffs, 0);

        // Set the Spells
        for i := 0 to script_Lists[LIST_SPELLS].ITEMS.Count - 1 do
          if (script_Lists[LIST_SPELLS].Checked[i]) then
            for j := 0 to High(MSI_Spells) do
              if (Lowercase(MSI_Spells[j].Name) = Lowercase(script_Lists[LIST_SPELLS].ITEMS.Strings[i])) then
              with MSI_Players[pIndex].Scripts[sIndex] do
              begin
                SetLength(Spells, Length(Spells) + 1);
                Spells[High(Spells)] := j;
                ClearSameIntegers(Spells);
                //Writeln('Player '+IntToStr(pIndex)+' Spells: '+ToStr(Spells));
              end;

        // Set the staffs
        for i := 0 to script_Lists[LIST_STAFFS].ITEMS.Count - 1 do
          if (script_Lists[LIST_STAFFS].Checked[i]) then
            for j := 0 to High(MSI_Items) do
              if (Lowercase(MSI_Items[j].Name) = Lowercase(script_Lists[LIST_STAFFS].ITEMS.Strings[i])) then
                with MSI_Players[pIndex].Scripts[sIndex] do
                begin
                  SetLength(Staffs, Length(Staffs) + 1);
                  Staffs[High(Staffs)] := j;
                  ClearSameIntegers(Staffs);
                  //Writeln('Player '+IntToStr(pIndex)+' Staffs: '+ToStr(Staffs));
                end;

        // Set the Alching Slots
        MSI_Players[pIndex].Scripts[sIndex].AlchSlots := StrToIntArr(script_Edits[EDIT_ALCH_SLOTS].Text);

         // Set the Heating Slots
        MSI_Players[pIndex].Scripts[sIndex].HeatSlots := StrToIntArr(script_Edits[EDIT_HEAT_SLOTS].Text);

        if (StrToIntDef(script_Edits[EDIT_LEVEL].Text, -1) = -1) then
          ShowMessage('Invalid max level! Please enter a number.')
        else
          MSI_Players[pIndex].Scripts[sIndex].MaxLevel := StrToInt(script_Edits[EDIT_LEVEL].Text);
      end;
  end;

  with MSI_Players[pIndex].Scripts[sIndex] do
  begin
    if (StrToIntDef(script_Edits[EDIT_TIME].Text, -1) = -1) then
      ShowMessage('Invalid Time! Please enter a number.')
    else
      Time := StrToInt(script_Edits[EDIT_TIME].Text);
  end;
end;

procedure script_OnClicks(Sender: TObject);
begin
  case Sender of
    script_Buttons[0]:
      begin
        //Writeln('Setting Info');
        script_SetInfo(ChoosePlay[IMG_TAB_NORM_5].ItemIndex, comboBox_Script_6.ItemIndex);
        script_Form.Visible := False;
      end;

    script_Buttons[1]:
      script_Form.Visible := False;
  end;
end;

procedure script_CreateComponents();
var
  i, x, y: Integer;
begin
  script_BackgroundImage := TImage.Create(script_Form);
  with script_BackgroundImage do
  begin
    Parent := script_Form;
    Visible := True;
    GetBitmapSize(frmBitmaps[SCRIPT_BGND], x, y);
    SetBounds(0, 0, x, y);
    DrawBitmap(frmBitmaps[SCRIPT_BGND], Canvas, 0, 0);
  end;

  for i := 0 to 1 do
  begin
    script_Buttons[i] := TButton.Create(script_Form);
    with script_Buttons[i] do
    begin
      Parent := script_Form;
      Width := 75;
      Height := 25;
      Top := script_Form.Height - (Height + 10);
      Left := 200 + (i * 80);
      OnClick := @script_OnClicks;
    end;
  end;

  script_Buttons[0].Caption := 'OK';
  script_Buttons[1].Caption := 'Cancel';

  // TCheckListBoxes
  for i := 0 to High(script_Lists) do
  begin
    script_Lists[i] := TCheckListBox.Create(script_Form);
    with script_Lists[i] do
    begin
      Parent := script_Form;
      Width := 160;
      Height := 110;
      Left := 20;
      Top := 35;
      Visible := False;

      case i of
        LIST_ROCKS:
          begin
            Hint := 'Check off all the rocks you want to mine';
          end;

        LIST_TREES:
          begin
            Hint := 'Check off all the trees you want to cut';
          end;

        LIST_FISHSPOTS:
          begin
            Hint := 'Check off all the fishing spots you want to fish from';
          end;

        LIST_OBJECTS:
          begin
            Hint := 'Check off all the objects you want the script to use';
          end;

        LIST_SPELLS:
          begin
            Hint := 'Check off all the spells you want to cast';
          end;

        LIST_STAFFS:
          begin
            Top := Top + Height + 30;
            Hint := 'Check off all the staffs you want to use';
          end;

        LIST_DROP:
          begin
            Top := Top + Height + 30;
            Hint := 'Check off the items you don''t want to drop (Powerskilling) and/or bank';
          end;

        LIST_MATERIALS:
          begin
            Top := Top + Height + 30;
            Hint := 'Check off the materials you want to use';
          end;
      end;

      ShowHint := True;
    end;
  end;

  // TLabels
  script_ListTexts := ['Rocks', 'Trees', 'Fishing Spots', 'Spells', 'Staffs', 'Don''t Drop/Bank', 'Materials', 'Cooking Spots', 'Objects'];
  for i := 0 to High(script_ListLabels) do
  begin
    script_ListLabels[i] := TLabel.Create(script_Form);
    with script_ListLabels[i] do
    begin
      Parent := script_Form;
      Height := 25;
      Width := script_Lists[i].Width;
      Left := script_Lists[i].Left;
      Top := script_Lists[i].Top - (Height - 5);
      Caption := script_ListTexts[i];
      Font.Color := 2070783;
      Visible := script_Lists[i].Visible;
    end;
  end;

  // TEdits
  for i := 0 to High(script_Edits) do
  begin
    script_Edits[i] := TEdit.Create(script_Form);
    with script_Edits[i] do
    begin
      Parent := script_Form;
      Height := 20;
      Visible := False;
      Width := 80;
      Left := (script_Lists[0].Left + script_Lists[0].Width) + (Width + 20);
      Top := (script_Lists[0].Top + ((15 + Height) * i));

      case i of
        EDIT_LOADS:
          begin
            Text := '0';
            Enabled := False;
            Hint := 'The number of loads to do for this script (disabled)';
          end;

        EDIT_TIME:
          begin
            Text := '0';
            Enabled := False;
            Hint := 'How long to run this script for (disabled)';
          end;

        EDIT_LEVEL:
          begin
            Text := '0';
            Hint := 'The maximum skill level you want to get (disabled)';
          end;

        EDIT_EXCEPTIONS:
          begin
            Hint := 'The inventory slots you don''t want to bank and/or drop (i.e. 1,2,3,4)';
          end;

        EDIT_ALCH_SLOTS:
          begin
            Hint := 'All the inventory slots that contain items you want to Alch (i.e. 1,2,3,4)';
          end;

        EDIT_HEAT_SLOTS:
          begin
            Hint := 'All the inventory slots that contain items you want to Heat (i.e. 1,2,3,4)';
          end;

        EDIT_PRIORITY:
          begin
            Hint := 'You can set MSI to search for one object more than another. '+#10+
                    'For example, if you''re ming Coal and Mithril, you can set '+#10+
                    'this to "80, 20" (no quotes) so 80% of the time it will look '+#10+
                    'for Coal and 20% of the time it will look for Mithril. Leaving '+#10+
                    'blank will give an equal chance for all objects.';
          end;
      end;

      ShowHint := True;
    end;
  end;

  // Edit TLabels
  script_EditTexts := ['Loads', 'Time', 'Level', 'Exceptions', 'Alching Slots', 'Heating Slots', 'Priority'];
  for i := 0 to High(script_EditLabels) do
  begin
    script_EditLabels[i] := TLabel.Create(script_Form);
    with script_EditLabels[i] do
    begin
      Parent := script_Form;
      Height := 25;
      Width := (script_Edits[i].Width);
      Left := script_Edits[i].Left - Width;
      Top := (script_Edits[i].Top + 4);
      Caption := script_EditTexts[i];
      Font.Color := 2070783;
      Visible := script_Edits[i].Visible;
    end;
  end;

  // TComboBoxes
  for i := 0 to High(script_combos) do
  begin
    script_combos[i] := TComboBox.Create(script_Form);
    with script_combos[i] do
    begin
      Parent := script_Form;
      Height := 20;
      Visible := False;
      Width := 80;
      Left := (script_Lists[0].Left + script_Lists[0].Width) + (Width + 20);
      Top := (script_edits[high(script_edits)].Top + ((height + 15) * i));

      case i of
        COMBO_COALBAG:
          begin
            hint := 'Do you want to use a coal bag?';
            text := 'False';
            items.Add('True');
            items.Add('False');
          end;
      end;

      showHint := True;
    end;
  end;

  // Combo TLabels
  script_ComboTexts := ['Use Coal Bag'];
  for i := 0 to High(script_ComboLabels) do
  begin
    script_ComboLabels[i] := TLabel.Create(script_Form);
    with script_ComboLabels[i] do
    begin
      Parent := script_Form;
      Height := 25;
      Width := (script_combos[i].Width);
      Left := script_combos[i].Left - Width;
      Top := (script_combos[i].Top + 4);
      Caption := script_ComboTexts[i];
      Font.Color := 2070783;
      Visible := script_combos[i].Visible;
    end;
  end;
end;

(*
   END OF SCRIPT SETUP COMPONENTS
   ==============================
*)

procedure AddScriptLocations(pIndex: Integer);
var
  i: Integer;
  script: TScript;
begin
  CheckListBox_4.Clear;

  with MSI_Players[pIndex] do
    for i := 0 to High(Scripts) do
    begin
      script := MSI_Scripts[Scripts[i].Name];

      if (script.PathInfo.StartLoc = LOC_POWER_SKILL) then
        CheckListBox_4.Items.Append(Capitalize(MSI_Locations[script.PathInfo.StartLoc].Name))
      else begin
        CheckListBox_4.Items.Append(Capitalize(MSI_Locations[script.PathInfo.StartLoc].Name))
        CheckListBox_4.Items.Append(Capitalize(MSI_Locations[script.PathInfo.EndLoc].Name));
      end;
    end;
end;

procedure CheckOffScripts(PlayerIndex: Integer);
var
  j, k: Integer;
begin
  for j := 0 to High(MSI_Players[PlayerIndex].Scripts) do
    for k := 0 to (CheckListBox_3.Items.Count - 1) do
      if (Lowercase(MSI_Scripts[MSI_Players[PlayerIndex].Scripts[j].Name].Name) = Lowercase(CheckListBox_3.Items.Strings[k])) then
        CheckListBox_3.Checked[k] := True;
end;

procedure CheckOffLocs(PlayerIndex: Integer);
var
  k: Integer;
begin
  AddScriptLocations(PlayerIndex);

  with MSI_Players[PlayerIndex] do
    for k := 0 to (CheckListBox_4.Items.Count - 1) do
      if (Lowercase(MSI_Locations[Location].Name) = Lowercase(CheckListBox_4.Items.Strings[k])) then
      begin
        CheckListBox_4.Checked[k] := True;
        Break;
      end;
end;

procedure LoadOther(pIndex: Integer);
begin
  time_Total_5.Text := IntToStr(MSI_Players[pIndex].TotalTime);
  time_Break_5.Text := IntToStr(MSI_Players[pIndex].BreakTime);
  loads_Break_5.Text := IntToStr(MSI_Players[pIndex].BreakLoads);
  loads_Total_5.Text := IntToStr(MSI_Players[pIndex].TotalLoads);
end;

procedure LoadPlayersToPanels(s: string);
var
  i: Integer;
begin
  s := Capitalize(s);

  for i := IMG_TAB_NORM_2 to IMG_TAB_NORM_5 do
    ChoosePlay[i].Items.Append(s);
end;

function SetScriptConsts(pIndex: Integer): TIntegerArray;
var
  i, j: Integer;
begin
  if (pIndex = -1) then
  begin
    //Writeln('[SetScriptConsts]: Invalid Player Index:'+IntToStr(pIndex));
    Exit;
  end;

  for i := 0 to (CheckListBox_3.Items.Count - 1) do
    if (CheckListBox_3.Checked[i]) then
      for j := 0 to High(MSI_Scripts) do
      begin
        if (MSI_Scripts[j].Name = '') then
          Continue;

        if (Lowercase(CheckListBox_3.Items.Strings[i]) = Lowercase(MSI_Scripts[j].Name)) then
        begin
          SetLength(Result, Length(Result) + 1);
          Result[High(Result)] := MSI_Scripts[j].Constant;
        end;
      end;

  SetLength(MSI_Players[pIndex].Scripts, Length(Result));

  for j := 0 to High(MSI_Players[pIndex].Scripts) do
  begin
    MSI_Players[pIndex].Scripts[j].Name := Result[j];
    //Writeln(IntToStr(MSI_Players[pIndex].Scripts[j].Name));
  end;

  //Writeln('Scripts: ' + ToStr(Result));
end;

function SetLocConsts(pIndex: Integer): Integer;
var
  i, j: Integer;
begin
  if (pIndex = -1) then
  begin
    //Writeln('[SetScriptConsts]: Invalid Player Index:'+IntToStr(pIndex));
    Exit;
  end;

  for i := 0 to (CheckListBox_4.Items.Count - 1) do
    if (CheckListBox_4.Checked[i]) then
      for j := 0 to High(MSI_Locations) do
      begin
        if (MSI_Locations[j].Name = '') then
          Continue;

        if (Lowercase(CheckListBox_4.Items.Strings[i]) = Lowercase(MSI_Locations[j].Name)) then
        begin
          Result := MSI_Locations[j].Constant;
          Break;
        end;
      end;

  MSI_Players[pIndex].Location := Result;
  //Writeln('Location: ' + ToStr(MSI_Players[i].Location));
end;

procedure SetOther(pIndex: Integer);
begin
  if (pIndex = -1) then
    Exit;

  with MSI_Players[pIndex] do
  begin
    try
      TotalTime := StrToInt(time_Total_5.Text);
    except
      ShowMessage('Total AnimTimer must be a number!');
      Exit;
    end;

    try
      BreakTime := StrToInt(time_Break_5.Text);
    except
      ShowMessage('Break after (AnimTimer) must be a number!');
      Exit;
    end;

    try
      BreakLoads := StrToInt(loads_Break_5.Text);
    except
      ShowMessage('Break after (loads) must be a number!');
      Exit;
    end;

    try
      TotalLoads := StrToInt(loads_Total_5.Text);
    except
      ShowMessage('Total loads must be a number!');
      Exit;
    end;
  end;

  //Writeln('Others set!');
end;

procedure SavePlayers;
var
  i, j: Integer;
  s: string;
begin
  intro_Settings(True);

  MSI_ClearFile(PATH_PLAYER);

  WriteINI('Number of Players', 'NumberOfPlayers', IntToStr(Length(MSI_Players)), PATH_PLAYER);
  for i := 0 to High(MSI_Players) do
    with MSI_Players[i] do
    begin
      s := '';
      Active := checkList_Players.Checked[i];
      SetLocConsts(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_3].Text));
      script_SetInfo(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_5].Text), comboBox_Script_6.ITEMS.IndexOf(comboBox_Script_6.Text));

      WriteINI(IntToStr(i), 'Name', Name, PATH_PLAYER);
      WriteINI(IntToStr(i), 'Pass', Pass, PATH_PLAYER);
      WriteINI(IntToStr(i), 'Nick', Nick, PATH_PLAYER);
      WriteINI(IntToStr(i), 'Pin', Pin, PATH_PLAYER);
      WriteINI(IntToStr(i), 'Active', BoolToStr(Active), PATH_PLAYER);
      WriteINI(IntToStr(i), 'Member', BoolToStr(Member), PATH_PLAYER);
      WriteINI(IntToStr(i), 'Location', IntToStr(Location), PATH_PLAYER);
      WriteINI(IntToStr(i), 'BreakTime', IntToStr(BreakTime), PATH_PLAYER);
      WriteINI(IntToStr(i), 'BreakLoads', IntToStr(BreakLoads), PATH_PLAYER);
      WriteINI(IntToStr(i), 'TotalTime', IntToStr(TotalTime), PATH_PLAYER);
      WriteINI(IntToStr(i), 'TotalLoads', IntToStr(TotalLoads), PATH_PLAYER);

      WriteINI(IntToStr(i), 'NumberOfScripts', IntToStr(Length(Scripts)), PATH_PLAYER);
      for j := 0 to High(Scripts) do
      begin
        // Set for all skills
        WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Name', IntToStr(Scripts[j].Name), PATH_PLAYER);
        WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Time', IntToStr(Scripts[j].Time), PATH_PLAYER);

        case MSI_Scripts[Scripts[j].Name].SkillConst of
          SKILL_WOODCUTTING, SKILL_FISHING, SKILL_MINING:
            begin
              // DontDrop
              if (Length(Scripts[j].DontDrop) > 0) then
                WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.DontDrop', IntArrToStr(Scripts[j].DontDrop), PATH_PLAYER);

              // Exceoptions
              if (Length(Scripts[j].Exceptions) > 0) then
                WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Exceptions', IntArrToStr(Scripts[j].Exceptions), PATH_PLAYER);

              // Priority
              if (Length(Scripts[j].Priority) > 0) then
                WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Priority', IntArrToStr(Scripts[j].Priority), PATH_PLAYER);

              // Level and Loads
              WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.MaxLevel', IntToStr(Scripts[j].MaxLevel), PATH_PLAYER);
              WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Loads', IntToStr(Scripts[j].Loads), PATH_PLAYER);

              // Trees, Rocks, and FishSpots
              case MSI_Scripts[Scripts[j].Name].SkillConst of
                SKILL_WOODCUTTING:
                  WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Trees', IntArrToStr(Scripts[j].Trees), PATH_PLAYER);

                SKILL_MINING:
                  WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Rocks', IntArrToStr(Scripts[j].Rocks), PATH_PLAYER);

                SKILL_FISHING:
                  WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.FishSpots', IntArrToStr(Scripts[j].FishSpots), PATH_PLAYER);
              end;
            end;

          SKILL_COOKING:
            begin
              // Level and Loads
              WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.MaxLevel', IntToStr(Scripts[j].MaxLevel), PATH_PLAYER);
              WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Loads', IntToStr(Scripts[j].Loads), PATH_PLAYER);

              // Materials
              WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Materials', IntArrToStr(Scripts[j].Materials), PATH_PLAYER);
              WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.CookingSpot', IntArrToStr(Scripts[j].CookingSpot), PATH_PLAYER);
            end;

          SKILL_NONE:
            begin
              // Loads
              WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Loads', IntToStr(Scripts[j].Loads), PATH_PLAYER);

              // Materials and Objects
              WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Materials', IntArrToStr(Scripts[j].Materials), PATH_PLAYER);
              WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Objects', IntArrToStr(Scripts[j].Objects), PATH_PLAYER);
            end;

          SKILL_MAGIC:
            begin
              // Staffs
              if (Length(Scripts[j].Staffs) > 0) then
                WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Staffs', IntArrToStr(Scripts[j].Staffs), PATH_PLAYER);

              // Spells
              if (Length(Scripts[j].Spells) > 0) then
                WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.Spells', IntArrToStr(Scripts[j].Spells), PATH_PLAYER);

              // AlchSlots
              if (Length(Scripts[j].AlchSlots) > 0) then
                WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.AlchSlots', IntArrToStr(Scripts[j].AlchSlots), PATH_PLAYER);

              // HeatSlots
              if (Length(Scripts[j].HeatSlots) > 0) then
                WriteINI(IntToStr(i), 'Script'+IntToStr(j)+'.HeatSlots', IntArrToStr(Scripts[j].HeatSlots), PATH_PLAYER);
            end;
        end;
      end;
    end;
end;

procedure LoadPlayers();
var
  i, j: Integer;
  nPlayers, s, p: string;
begin
  if (not FileExists(PATH_PLAYER)) then
    Exit;

  nPlayers := ReadINI('Number of Players', 'NumberOfPlayers', PATH_PLAYER);
  SetLength(MSI_Players, StrToInt(nPlayers));

  for i := 0 to High(MSI_Players) do
    with MSI_Players[i] do
    begin
      Name := ReadINI(IntToStr(i), 'Name', PATH_PLAYER);
      if Name = '####' then
        Continue;
      Pass := ReadINI(IntToStr(i), 'Pass', PATH_PLAYER);
      Nick := ReadINI(IntToStr(i), 'Nick', PATH_PLAYER);
      Pin := ReadINI(IntToStr(i), 'Pin', PATH_PLAYER);
      Active := StrToBool(ReadINI(IntToStr(i), 'Active', PATH_PLAYER));
      Member := StrToBool(ReadINI(IntToStr(i), 'Member', PATH_PLAYER));
      Location := StrToIntDef(ReadINI(IntToStr(i), 'Location', PATH_PLAYER), -1);
      BreakTime := StrToIntDef(ReadINI(IntToStr(i), 'BreakTime', PATH_PLAYER), -1);
      BreakLoads := StrToIntDef(ReadINI(IntToStr(i), 'BreakLoads', PATH_PLAYER), -1);
      TotalTime := StrToIntDef(ReadINI(IntToStr(i), 'TotalTime', PATH_PLAYER), -1);
      TotalLoads := StrToIntDef(ReadINI(IntToStr(i), 'TotalLoads', PATH_PLAYER), -1);

      if (Member) then
      begin
        comboBox_Member.Text := 'True';
        s := '[P2P] '
      end else begin
        comboBox_Member.Text := 'False';
        s := '[F2P] ';
      end;

      if (Pin <> '') then
        p := 'Pin';

      checkList_Players.Items.Append(IntToStr(i) + ': ' + s + Capitalize(Name) + ' (' + Pass + ')' + p + Pin);
      checkList_Players.Checked[i] := Active;

      LoadPlayersToPanels(Name);

      SetLength(Scripts, StrToIntDef(ReadINI(IntToStr(i), 'NumberOfScripts', PATH_PLAYER), -1));
      for j := 0 to High(Scripts) do
      begin
        Scripts[j].Name := StrToIntDef(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.Name', PATH_PLAYER), -1);
        Scripts[j].Time := StrToIntDef(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.Time', PATH_PLAYER), -1);

        try
          Scripts[j].Trees := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.Trees', PATH_PLAYER));
          Scripts[j].Rocks := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.Rocks', PATH_PLAYER));
          Scripts[j].FishSpots := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.FishSpots', PATH_PLAYER));
          Scripts[j].Spells := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.Spells', PATH_PLAYER));
          Scripts[j].Materials := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.Materials', PATH_PLAYER));
          Scripts[j].CookingSpot := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.CookingSpot', PATH_PLAYER));
          Scripts[j].Objects := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.Objects', PATH_PLAYER));
          Scripts[j].DontDrop := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.DontDrop', PATH_PLAYER));
          Scripts[j].Exceptions := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.Exceptions', PATH_PLAYER));
          Scripts[j].Priority := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.Priority', PATH_PLAYER));
          Scripts[j].AlchSlots := StrToIntArr(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.AlchSlots', PATH_PLAYER));
          Scripts[j].Loads := StrToIntDef(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.Loads', PATH_PLAYER), -1);
          Scripts[j].MaxLevel := StrToIntDef(ReadINI(IntToStr(i), 'Script'+IntToStr(j)+'.MaxLevel', PATH_PLAYER), -1);
        except
          //Writeln('INI Doesn''t Exist!');
        end;

        if (Scripts[j].Loads = -1) then
          Scripts[j].Loads := 0;

        if (Scripts[j].MaxLevel = -1) then
          Scripts[j].MaxLevel := 0;

        if (Scripts[j].Time = -1) then
          Scripts[j].Time := 0;
      end;
    end;

  tImages[IMG_LOAD_TAB_NORM].Enabled := False;
  btn_DeletePlayer.Enabled := (Length(MSI_Players) >= 1);
  for i := Low(Next) to High(Next) do
    Next[i].Enabled := (Length(MSI_Players) >= 1);
  //ShowMessage('Loaded Players');
end;

procedure OnMouseMove(Sender: TObject; Shift: TShiftState; x, y: Integer);
var
  hi, i, bmp, h: Integer;
  imgSwap, bmpArr, imgArr: Array of Integer;
begin
  if(MouseDown) then
  begin
    MainForm.Left := MainForm.Left - (cPoint.X - X);
    MainForm.Top := MainForm.Top - (cPoint.Y - Y);

    Exit;
  end;

  bmpArr := [ X_NORM, Q_NORM, LOAD_TAB_NORM,
              SAVE_TAB_NORM, TAB_NORM_1, TAB_NORM_2,
              TAB_NORM_3, TAB_NORM_4, TAB_NORM_5, TAB_NORM_0, RUN_NORM ];

  imgArr := [ IMG_X_NORM, IMG_Q_NORM, IMG_LOAD_TAB_NORM,
              IMG_SAVE_TAB_NORM, IMG_TAB_NORM_1, IMG_TAB_NORM_2,
              IMG_TAB_NORM_3, IMG_TAB_NORM_4, IMG_TAB_NORM_5, IMG_TAB_NORM_0, IMG_RUN_NORM ];

  hi := High(bmpArr);
  case Sender of
    tImages[IMG_BGND], Panels[IMG_TAB_NORM_1],
    Panels[IMG_TAB_NORM_2], Panels[IMG_TAB_NORM_3], Panels[IMG_TAB_NORM_4],
    Panels[IMG_TAB_NORM_5], Panels[IMG_TAB_NORM_0]:
      begin
        for i := 0 to hi do
        begin
          if (not isActiveImage[imgArr[i]]) then
            Continue;

          bmp := frmBitmaps[bmpArr[i]];
          DrawBitmap(bmp, tImages[imgArr[i]].Canvas, 0, 0);
          isActiveImage[imgArr[i]] := False;
        end;
      end;
  end;

  for h := 0 to hi do
    case Sender of
      tImages[imgArr[h]]:
        begin
          imgSwap := [imgArr[h], frmBitmaps[bmpArr[h] + 1]];
          if (not isActiveImage[imgSwap[0]]) then
          begin
            DrawBitmap(imgSwap[1],tImages[imgSwap[0]].Canvas,0,0);
            isActiveImage[imgSwap[0]] := True;
            for i := 0 to hi do
            begin
              if (Sender = tImages[imgArr[i]]) then
                Continue;

              if (not isActiveImage[imgArr[i]]) then
                Continue;

              if (i = imgSwap[0] - 1) then
                Continue;

              bmp := frmBitmaps[bmpArr[i]];
              DrawBitmap(bmp, tImages[imgArr[i]].Canvas, 0, 0);
              isActiveImage[imgArr[i]] := False;
            end;
          end;
      end;
  end;
end;

const
  MAX_MOVE = 315;

var
  accel, pMoved, senderTab, pan: integer;
  onLeft: Boolean;

procedure OnTimerEnabled(Sender: TObject);
var
  i: Integer;
begin
  accel := accel + 2;
  pMoved := pMoved + accel;

  if (senderTab = IMG_TAB_NORM_0) then
  begin
    panels[IMG_TAB_NORM_0].Width := panels[IMG_TAB_NORM_0].Width + accel;

    for i := IMG_TAB_NORM_1 to IMG_TAB_NORM_5 do
    begin
      if (not isLeftTab[i]) then
        Continue;

      tImages[i].Left := tImages[i].Left + accel;

      if (pMoved >= MAX_MOVE) then
      begin
        isLeftTab[i] := False;
        AnimTimer.Enabled := False;
        tImages[i].Left := tImages[i].Left - 5;
      end;
    end;
  end else
  begin
    if (onLeft) then
      for i := senderTab to IMG_TAB_NORM_5 do
      begin
        if (i = senderTab) or (not isLeftTab[i]) then
          Continue;

        tImages[i].Left := tImages[i].Left + accel;

        if (pMoved >= MAX_MOVE) then
        begin
          isLeftTab[i] := False;
          AnimTimer.Enabled := False;
          tImages[i].Left := tImages[i].Left - 5;
        end;

        //Writeln(BoolToStr(isLeftTab[i]));
      end
    else begin
      panels[IMG_TAB_NORM_0].Width := panels[IMG_TAB_NORM_0].Width - accel;

      for i := senderTab downto IMG_TAB_NORM_1 do
      begin
        if (isLeftTab[i]) then
          Continue;

        tImages[i].Left := tImages[i].Left - accel;

        if (pMoved >= MAX_MOVE) then
        begin
          isLeftTab[i] := True;
          AnimTimer.Enabled := False;
          tImages[i].Left := tImages[i].Left + 5;
        end;

      end;
    end;
  end;

  for i := IMG_TAB_NORM_1 to IMG_TAB_NORM_5 do
  begin
    panels[i].left := tImages[i].left + tImages[i].width + 2
    if i <> IMG_TAB_NORM_5 then
      panels[i].width := tImages[i + 1].left - panels[i].left - 2
    else
      panels[i].width := MainForm.width - panels[i].left - 10;
  end;

  if (senderTab = IMG_TAB_NORM_0) then
    if (pMoved >= MAX_MOVE) then
      panels[IMG_TAB_NORM_0].Width := panels[IMG_TAB_NORM_0].Width - 10;
end;

procedure OnTabClick(Sender: TObject);
var
  i: integer;
begin
  if not AnimTimer.ENABLED then
  begin
    accel := 0;
    pMoved := 0;
    AnimTimer.enabled := true;
    pan := senderTab;

    if (Sender = tImages[IMG_TAB_NORM_0]) then
      senderTab := IMG_TAB_NORM_0;

    for i := IMG_TAB_NORM_1 to IMG_TAB_NORM_5 do
      if (Sender = tImages[i]) then
      begin
        senderTab := i;
        if (isLeftTab[senderTab]) then
          onLeft := True
        else
          onLeft := False;
      end;
  end;
end;

procedure OnClickEvents(Sender: TObject); // OnClick
var
  i, t, btn: integer;
  bmpArr: TIntegerArray;
begin
  for i := IMG_TAB_NORM_1 to IMG_TAB_NORM_5 do
    if (isLeftTab[i]) then
      Inc(t);

  for i := IMG_TAB_NORM_1 to IMG_TAB_NORM_5 do
    case Sender of
      tImages[i]:
        begin
          if (isLeftTab[i]) then
            if (t <= (i - (IMG_TAB_NORM_5 - IMG_TAB_NORM_1))) then
              Exit;

          OnTabClick(Sender);

          if (not isLeftTab[i]) then
          begin
            bmpArr := [TAB_NORM_1, TAB_NORM_2, TAB_NORM_3, TAB_NORM_4, TAB_NORM_5];
            DrawBitmap(frmBitmaps[bmpArr[i-IMG_TAB_NORM_1]], tImages[i].Canvas, 0, 0);
          end;

          SetScriptConsts(ChoosePlay[IMG_TAB_NORM_2].ItemIndex);
          SetLocConsts(ChoosePlay[IMG_TAB_NORM_3].ItemIndex);
          SetOther(ChoosePlay[IMG_TAB_NORM_4].ItemIndex);
        end;
    end;

  case Sender of
    tImages[IMG_X_NORM]:
      begin
        for i := 0 to BITMAP_COUNT - 1 do
          FreeBitmap(frmBitmaps[i]);

        MSI_FreeAllItems;

        MainForm.ModalResult := mrOk;
      end;

    tImages[IMG_Q_NORM]: OpenWebPage('http://villavu.com/forum/showthread.php?t=57723');

    tImages[IMG_TAB_NORM_0]:
      begin
        if (t <= 0) then
          Exit;

        OnTabClick(Sender);
      end;

    tImages[IMG_SAVE_TAB_NORM]:
      begin
        DrawBitmap(frmBitmaps[SAVE_TAB_NORM],tImages[IMG_SAVE_TAB_NORM].Canvas, 0, 0);
        SetScriptConsts(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_2].Text));
        SetLocConsts(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_3].Text));
        SetOther(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_4].Text));
        SavePlayers;
        ShowMessage('Saved Players');
      end;

    tImages[IMG_LOAD_TAB_NORM]:
      begin
        DrawBitmap(frmBitmaps[LOAD_TAB_NORM],tImages[IMG_LOAD_TAB_NORM].Canvas, 0, 0);
        LoadPlayers;
      end;

    tImages[IMG_RUN_NORM]:
      begin
        ScriptReady := True;

        intro_Settings(True);
        script_SetInfo(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_5].Text), comboBox_Script_6.ITEMS.IndexOf(comboBox_Script_6.Text));
        SetScriptConsts(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_2].Text));
        SetLocConsts(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_3].Text));
        SetOther(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_4].Text));
        btn := MessageDlg('Save Settings?', 'Would you like to save your user information for later use?', mtConfirmation, [mbYes, mbNo]);
        if btn = mrYes then
          SavePlayers;
        CurrentPlayer := StrToIntDef(edit_CurPlayer.Text, 0);
        if (CurrentPlayer = 0) then
          for i := 0 to High(MSI_Players) do
            if (MSI_Players[i].Active) then
            begin
              CurrentPlayer := i;
              Break;
            end;

        for i := 0 to BITMAP_COUNT - 1 do
          FreeBitmap(frmBitmaps[i]);

        MainForm.ModalResult := mrOk;
      end;

    comboBox_Script_6:
      script_SetInfo(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_5].Text), comboBox_Script_6.ITEMS.IndexOf(comboBox_Script_6.Text));
  end;

  if (sender = tImages[IMG_TAB_NORM_3]) then
    showMessage('You no longer have to enter the player''s location.'+#13+#10+
                'Please skip to panel 4. ');
end;

{******************************************************************************}
{ Name: function GenerateNick(Username: string): string;                       }
{ By: Coh3n                                                                    }
{ Description: Generates the players nickname based on their username          }
{******************************************************************************}
function GenerateNick(Username: string): string;
var
  i, j: Integer;
  s: TStringArray;
begin
  s := Explode(' ', Username);
  for i := 0 to High(s) do
    if (Length(s[i]) >= 4) then
    begin
      for j := 2 to 4 do
        Result := Result + s[i][j];

      Break;
    end;

  //Writeln('Username: ' + Username);
  //Writeln('Nickname: ' + Result);
end;

{******************************************************************************}
{ Name: procedure AddPlayer();                                                 }
{ By: Coh3n                                                                    }
{ Description: Adds a player to the player array. Called when the Add Player   }
{              button is pressed                                               }
{******************************************************************************}
procedure AddPlayer();
var
  i, h: Integer;
begin
  SetLength(MSI_Players, Length(MSI_Players) + 1);

  if ((Length(MSI_Players) >= 1)) then
  begin
    btn_DeletePlayer.Enabled := True;

    for i := Low(Next) to High(Next) do
      Next[i].Enabled := True;
  end;

  h := High(MSI_Players);
  with MSI_Players[h] do
  begin
    Name   := edit_User.Text;
    Pass   := edit_Pass.Text;
    //Nick   := GenerateNick(Name);
    Pin    := edit_Pin.Text;
    Active := checkList_Players.Checked[checkList_Players.ItemIndex];
    Member := StrToBool(comboBox_Member.Text);

    //Writeln(Name);
    //Writeln(Pass);
    //Writeln(Nick);
    //Writeln(Pin);
    //Writeln(BoolToStr(Active));
    //Writeln(BoolToStr(Member));
  end;

  //Writeln('Player Length: ' + IntToStr(Length(MSI_Players)));
end;

{******************************************************************************}
{ Name: procedure RemovePlayer();                                              }
{ By: Masterkill & Coh3n                                                       }
{ Description: Removes a player from the player array. Called when the Remove  }
{              Player button is pressed                                        }
{******************************************************************************}
procedure RemovePlayer(Index: Integer);
var
  i: Integer;
begin
  //Writeln(IntToStr(Index));

  if (not (Index = High(MSI_Players))) then
    if (Index + 1 = High(MSI_Players)) then
      MSI_Players[Index] := MSI_Players[High(MSI_Players)]
    else
      for i := Index to High(MSI_Players) - 1 do
        MSI_Players[i] := MSI_Players[i + 1];

  SetLength(MSI_Players, Length(MSI_Players) - 1);

  if ((Length(MSI_Players) <= 1)) then
    for i := Low(Previous) to High(Previous) do
      Previous[i].Enabled := False;

  if ((Length(MSI_Players) = 0)) then
    for i := Low(Next) to High(Next) do
      Next[i].Enabled := False;

  //Writeln('Player Length: ' + IntToStr(Length(MSI_Players)));
end;

procedure PanelOneClicks(Sender: TObject); // OnChange
var
  sel, i: integer;
  s, p: string;
begin
  case sender of
    btn_AddPlayer:
      begin
        if (StrToBool(comboBox_Member.Text)) then
          s := '[P2P] '
        else
          s := '[F2P] ';

        if (edit_Pin.Text <> '') then
          p := 'Pin';

        checkList_Players.Items.Append(IntToStr(Length(MSI_Players)) + ': ' + s + Capitalize(edit_User.Text) + ' (' + edit_Pass.Text + ')' + p + edit_Pin.Text);

        // Add player to the combo box on other panels
        LoadPlayersToPanels(edit_User.Text);

        checkList_Players.Checked[checkList_Players.items.Count - 1] := true;
        checkList_Players.ItemIndex := checkList_Players.Items.Count - 1;

        AddPlayer();

        btn_DeletePlayer.Enabled := (Length(MSI_Players) > 0);
        edit_User.Text := '';
        edit_Pass.Text := '';
        edit_Pin.Text := '';
     end;

    btn_DeletePlayer:
      begin
        RemovePlayer(checkList_Players.ItemIndex);

        if checkList_Players.ItemIndex >= 0 then
          sel := checkList_Players.ItemIndex;
        checkList_Players.Items.Delete(sel);

        for i := IMG_TAB_NORM_2 to IMG_TAB_NORM_5 do
          ChoosePlay[i].Items.Delete(sel);

        if sel = 0 then
          sel := 1;
        checkList_Players.ItemIndex := sel - 1;

        btn_DeletePlayer.Enabled := (Length(MSI_Players) > 0);
        edit_User.Text := '';
        edit_Pass.Text := '';
        edit_Pin.Text := '';
      end;
  end;
end;

(**
 * Used to enable/disable the next and previous buttons depending on the index
 * currently selected in the combo box. Avoids Out of range errors.
 *)
procedure ChangeButtonState(ComboBox: TComboBox; PButton, NButton: TButton);
var
  where: string;
begin
  // If last in the list (High)
  if (ComboBox.ItemIndex = (ComboBox.Items.Count - 1)) then
    where := 'high'
  else
    // If first in the list (Low)
    if (ComboBox.ItemIndex = 0) then
      where := 'low'
    else
      where := 'middle'; // If not high and not low then it's in the middle

  if (ComboBox.Items.Count <= 1) then
    where := 'all';

  case where of
    'low':
      begin
        PButton.Enabled := False;
        NButton.Enabled := True;
      end;

    'middle':
      begin
        PButton.Enabled := True;
        NButton.Enabled := True;
      end;

    'high':
      begin
        PButton.Enabled := True;
        NButton.Enabled := False;
      end;

    'all':
      begin
        PButton.Enabled := False;
        NButton.Enabled := False;
      end;

  end;
end;

procedure PlayerChangeUpdate(Sender: TObject); // OnChange
var
  i, pIndex: integer;
begin
  for i := IMG_TAB_NORM_2 to IMG_TAB_NORM_5 do
    case sender of
      ChoosePlay[i]:
        begin
          ChangeButtonState(ChoosePlay[i], Previous[i], Next[i]);
          pIndex := GetPlayerIndex(ChoosePlay[i].Text);
        end;
    end;

  case sender of
    ChoosePlay[IMG_TAB_NORM_2]:
      begin
        CheckListBox_3.Enabled := True;

        for i := 0 to CheckListBox_3.ITEMS.Count - 1 do
          CheckListBox_3.Checked[i] := False;

        CheckOffScripts(pIndex);
      end;

    ChoosePlay[IMG_TAB_NORM_3]:
      begin
        CheckListBox_4.Enabled := True;

        for i := 0 to CheckListBox_4.ITEMS.Count - 1 do
          CheckListBox_4.Checked[i] := False;

        CheckOffLocs(pIndex);
      end;

    ChoosePlay[IMG_TAB_NORM_4]:
      begin
        time_Total_5.Enabled := True;
        time_Break_5.Enabled := True;
        loads_Break_5.Enabled := True;
        loads_Total_5.Enabled := True;

        LoadOther(pIndex);
      end;

    ChoosePlay[IMG_TAB_NORM_5]:
      begin
        if (Length(MSI_Players[ChoosePlay[IMG_TAB_NORM_5].ItemIndex].Scripts) > 0) then
          nScript.Enabled := True;

        SetScriptConsts(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_2].Text));

        script_FillCombo();
        script_HideComponents();
        script_Form.Visible := False;
      end;
  end;
end;

procedure PlayerControls(Sender: TObject); // OnClick
var
  i: Integer;
begin
  for i := IMG_TAB_NORM_2 to IMG_TAB_NORM_5 do
    case Sender of
      ChoosePlay[i]:
        pBoxIndex := ChoosePlay[i].ItemIndex;

      Previous[i]:
        begin
          if (ChoosePlay[i].ItemIndex > 0) then
            ChoosePlay[i].ItemIndex := ChoosePlay[i].ItemIndex - 1;

          ChangeButtonState(ChoosePlay[i], Previous[i], Next[i]);
        end;

      Next[i]:
        begin
          if (ChoosePlay[i].ItemIndex < ChoosePlay[i].Items.Count) then
            ChoosePlay[i].ItemIndex := ChoosePlay[i].ItemIndex + 1;

          ChangeButtonState(ChoosePlay[i], Previous[i], Next[i]);
        end;
    end;

  case Sender of
    ChoosePlay[IMG_TAB_NORM_2]: SetScriptConsts(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_2].Text));
    ChoosePlay[IMG_TAB_NORM_3]: SetLocConsts(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_3].Text));
    ChoosePlay[IMG_TAB_NORM_4]: SetOther(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_4].Text));
    ChoosePlay[IMG_TAB_NORM_5]: script_SetInfo(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_5].Text), comboBox_Script_6.ITEMS.IndexOf(comboBox_Script_6.Text));

    Next[IMG_TAB_NORM_2], Previous[IMG_TAB_NORM_2]:
      begin
        if (Sender = Next[IMG_TAB_NORM_2]) then
          SetScriptConsts(ChoosePlay[IMG_TAB_NORM_2].ItemIndex - 1)
        else
          SetScriptConsts(ChoosePlay[IMG_TAB_NORM_2].ItemIndex + 1);

        PlayerChangeUpdate(ChoosePlay[IMG_TAB_NORM_2]);
      end;

    Next[IMG_TAB_NORM_3], Previous[IMG_TAB_NORM_3]:
      begin
        if (Sender = Next[IMG_TAB_NORM_3]) then
          SetLocConsts(ChoosePlay[IMG_TAB_NORM_3].ItemIndex - 1)
        else
          SetLocConsts(ChoosePlay[IMG_TAB_NORM_3].ItemIndex + 1);

        PlayerChangeUpdate(ChoosePlay[IMG_TAB_NORM_3]);
      end;

    Next[IMG_TAB_NORM_4], Previous[IMG_TAB_NORM_4]:
      begin
        if (Sender = Next[IMG_TAB_NORM_4]) then
          SetOther(ChoosePlay[IMG_TAB_NORM_4].ItemIndex - 1)
        else
          SetOther(ChoosePlay[IMG_TAB_NORM_4].ItemIndex + 1);

        PlayerChangeUpdate(ChoosePlay[IMG_TAB_NORM_4]);
      end;

    Next[IMG_TAB_NORM_5], Previous[IMG_TAB_NORM_5]:
      begin
        if (Sender = Next[IMG_TAB_NORM_5]) then
          script_SetInfo(ChoosePlay[IMG_TAB_NORM_5].ItemIndex - 1, comboBox_Script_6.ITEMS.IndexOf(comboBox_Script_6.Text))
        else
          script_SetInfo(ChoosePlay[IMG_TAB_NORM_5].ItemIndex + 1, comboBox_Script_6.ITEMS.IndexOf(comboBox_Script_6.Text));

        if (Length(MSI_Players[ChoosePlay[IMG_TAB_NORM_5].ItemIndex].Scripts) > 0) then
          nScript.Enabled := True;

        script_FillCombo();
        script_Form.Visible := False;
      end;
  end;
end;

procedure PanelFiveClicks(Sender: TObject); // OnChange
var
  pIndex, i: Integer;
begin
  case sender of
    ComboBox_Script_6:
      begin
        script_ShowComponents();

        for i := 0 to script_Lists[LIST_DROP].ITEMS.Count - 1 do
          if (script_Lists[LIST_DROP].Checked[i]) then
            script_Lists[LIST_DROP].Checked[i] := False;

        pIndex := GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_5].Text);

        ChangeButtonState(ComboBox_Script_6, pScript, nScript);
        script_FillComponents(pIndex);
        script_Form.Visible := True;
      end;

    nScript:
      begin
        if ComboBox_Script_6.ItemIndex < ComboBox_Script_6.ITEMS.Count then
          ComboBox_Script_6.ItemIndex := ComboBox_Script_6.ItemIndex + 1;

        ChangeButtonState(ComboBox_Script_6, pScript, nScript);

        script_SetInfo(GetPlayerIndex(ChoosePlay[IMG_TAB_NORM_5].Text), comboBox_Script_6.ItemIndex - 1);
        PanelFiveClicks(ComboBox_Script_6);
        script_Form.Visible := True;
      end;

    pScript:
      begin
        if ComboBox_Script_6.ItemIndex > 0 then
          ComboBox_Script_6.ItemIndex := ComboBox_Script_6.ItemIndex - 1;

        ChangeButtonState(ComboBox_Script_6, pScript, nScript);

        script_SetInfo(ChoosePlay[IMG_TAB_NORM_5].ItemIndex, comboBox_Script_6.ITEMS.IndexOf(comboBox_Script_6.Text) + 1);
        PanelFiveClicks(ComboBox_Script_6);
        script_Form.Visible := True;
      end;
  end;
end;

// Used to display a background image on the panels
var
  bgndPanel: TImage;
  a, b: Integer;

procedure ShowMSIForm;
var
  i, pan: Integer;
  consts: TintegerArray;
  bmpArr: TStringArray;
  xy: TPointArray;
  visibl: array of boolean;
  wh: TPoint;
begin
  bmpArr := ['BGND','X_NORM','X_HOVER','Q_NORM','Q_HOVER','LOAD_TAB_NORM','LOAD_TAB_HOVER','SAVE_TAB_NORM','SAVE_TAB_HOVER','TAB_NORM_1','TAB_HOVER_1','TAB_NORM_2','TAB_HOVER_2','TAB_NORM_3','TAB_HOVER_3','TAB_NORM_4','TAB_HOVER_4','TAB_NORM_5','TAB_HOVER_5','TAB_NORM_0','TAB_HOVER_0', 'BGND_PANEL', 'RUN_NORM', 'RUN_HOVER', 'SCRIPT_SETUP_BGND'];
  for i := 0 to High(frmBitmaps) do
    frmBitmaps[i] := LoadBitmap(PATH_FORM_BITMAPS + bmpArr[i] + '.png');

  MainForm := TForm.Create(nil);
  MainForm.SetBounds({L} 100, {T} 100, {W} 600, {H} 400);
  MainForm.Position := poMainFormCenter;  // Centre of the Simba window. :-)
  MainForm.BorderStyle := bsNone;

  script_Form := TForm.Create(MainForm);
  with script_Form do
  begin
    Width := 383;
    Height := 333;
    Top := MainForm.Top + (MainForm.Height / 4);
    Left := MainForm.Left + (MainForm.Width / 4);
    BorderStyle := bsNone;
  end;
  script_CreateComponents();

  AnimTimer := TTimer.Create(MainForm);
  with AnimTimer do
  begin
    OnTimer := @OnTimerEnabled;
    Interval := 10;
    Enabled := false;
  end;

  xy     := [Point(0, 0), Point(575, 7), Point(557, 7), Point(7, 69),   Point(81, 69),  Point(386, 100), Point(427, 100), Point(468, 100), Point(509, 100), Point(550, 100), Point(8, 222), Point(519, 69) ];
  SetArrayLength(visibl, GetArrayLength(xy));
  consts := [BGND,        X_NORM,        Q_NORM,        LOAD_TAB_NORM,  SAVE_TAB_NORM,  TAB_NORM_1,      TAB_NORM_2,      TAB_NORM_3,      TAB_NORM_4,      TAB_NORM_5,      TAB_NORM_0,    RUN_NORM       ];

  for i := 0 to IMG_COUNT - 1 do
  begin
    tImages[i] := TImage.Create(MainForm)
    with tImages[i] do
    begin
      Parent := MainForm;
      GetBitmapSize(frmBitmaps[consts[i]], wh.x, wh.y);
      SetBounds(xy[i].x, xy[i].y, wh.x, wh.y);
      OnMouseMove := @OnMouseMove;
      OnClick := @OnClickEvents;

      if(I = IMG_BGND) then
      begin
        OnMouseDown := @BGMouseDown;
        OnMouseUp := @BGMouseUp;
      end;

      isActiveImage[i] := False;
    end;
    DrawBitmap(frmBitmaps[consts[i]], tImages[i].canvas, 0, 0);
  end;

  for i := low(panels) to high(panels) do
  begin
    panels[i] := TPanel.Create(MainForm);
    panels[i].parent := MainForm;
    GetBitmapSize(frmBitmaps[consts[i]], wh.x, wh.y);
    panels[i].SetBounds(xy[i].x + wh.x, xy[i].y, 0, wh.y);
    panels[i].BevelWidth := 0;

    if (i = High(panels)) then
      panels[i].SetBounds(10 + tImages[IMG_TAB_NORM_0].Width, 100,
                          tImages[IMG_TAB_NORM_1].Left - (tImages[IMG_TAB_NORM_0].Left + tImages[IMG_TAB_NORM_0].Width) - 4,
                          tImages[IMG_TAB_NORM_1].Height);

    bgndPanel := TImage.Create(panels[i]);
    bgndPanel.Parent := panels[i];
    bgndPanel.Visible := True;
    GetBitmapSize(frmBitmaps[BGND_PANEL], a, b);
    bgndPanel.SetBounds(0, 0, a, b);
    DrawBitmap(frmBitmaps[BGND_PANEL], bgndPanel.Canvas, 0, 0);
  end;
  panels[IMG_TAB_NORM_3].enabled := false;
  panels[IMG_TAB_NORM_3].onEnter := @onClickEvents;

  for i := Low(Previous) to High(Previous) do
  begin
    Previous[i] := TButton.Create(panels[i]);
    Previous[i].Parent := panels[i];
    Previous[i].SetBounds(35, 24, 73, 25);
    Previous[i].Caption := 'Previous';
    Previous[i].OnClick := @PlayerControls;
    Previous[i].Enabled := False;
    Previous[i].Hint := 'Go to the previous player in the list';
    Previous[i].ShowHint := True;

    if (i = IMG_TAB_NORM_5) then
      Previous[i].SetBounds(35, 50, 73, 25);

    ChoosePlay[i] := TComboBox.Create(panels[i]);
    ChoosePlay[i].Parent := panels[i];
    ChoosePlay[i].SetBounds(Previous[i].left + Previous[i].width + 5,Previous[i].top + 1, 115, 21);
    ChoosePlay[i].OnChange := @PlayerChangeUpdate;
    ChoosePlay[i].OnKeyPress := @PreventTyping;
    ChoosePlay[i].OnClick := @PlayerControls;
    ChoosePlay[i].Hint := 'Choose a player from the list to setup';
    ChoosePlay[i].ShowHint := True;

    Next[i] := TButton.Create(panels[i]);
    Next[i].Parent := panels[i];
    Next[i].SetBounds(ChoosePlay[i].left + ChoosePlay[i].width + 5, Previous[i].top, 75, 25);
    Next[i].Caption := 'Next';
    Next[i].OnClick := @PlayerControls;
    Next[i].Enabled := False;
    Next[i].Hint := 'Go to the next player in the list';
    Next[i].ShowHint := True;
  end;

  pan := IMG_TAB_NORM_1;

  checkList_Players := TCheckListBox.Create(panels[pan]);
  checkList_Players.Parent := panels[pan];
  checkList_Players.SetBounds(10, 55, 225, 200);
  checkList_Players.Hint := 'A list of all your Runscape players';
  checkList_Players.ShowHint := True;

  label_Username := TLabel.Create(panels[pan]);
  label_Username.Parent := panels[pan];
  label_Username.Setbounds(245,55,50,13);
  label_Username.Caption := 'Username';
  label_Username.Font.Color := 2070783;

  edit_User := TEdit.Create(panels[pan]);
  edit_User.Parent := panels[pan];
  edit_User.SetBounds(label_Username.left,label_Username.top + label_Username.height + 5,83,21);
  edit_User.Hint := 'The name you use to login to Runescape';
  edit_User.ShowHint := True;

  label_Pass := TLabel.Create(panels[pan]);
  label_Pass.Parent := panels[pan];
  label_Pass.Setbounds(label_Username.left, edit_User.top + edit_User.height + 10,32,13);
  label_Pass.Caption := 'Password';
  label_Pass.Font.Color := 2070783;

  edit_Pass := TEdit.Create(panels[pan]);
  edit_Pass.Parent := panels[pan];
  edit_Pass.SetBounds(label_Username.left,label_Pass.top + label_Pass.height + 5,83,21);
  edit_Pass.Hint := 'The password you use to login to Runscape';
  edit_Pass.ShowHint := True;

  label_Pin := TLabel.Create(panels[pan]);
  label_Pin.Parent := panels[pan];
  label_Pin.Setbounds(label_Username.left, edit_Pass.top + edit_Pass.height + 10,32,13);
  label_Pin.Caption := 'Pin';
  label_Pin.Font.Color := 2070783;

  edit_Pin := TEdit.Create(panels[pan]);
  edit_Pin.Parent := panels[pan];
  edit_Pin.SetBounds(label_Username.left, label_Pin.top + label_Pin.height + 5, 83, 21);
  edit_Pin.MaxLength := 4;
  edit_Pin.Hint := 'Your Runescape''s bank PIN';
  edit_Pin.ShowHint := True;

  label_Member := TLabel.Create(panels[pan]);
  label_Member.Parent := panels[pan];
  label_Member.Setbounds(label_Username.left, edit_Pin.top + edit_Pin.height + 10,32,13);
  label_Member.Caption := 'Members';
  label_Member.Font.Color := 2070783;

  comboBox_Member := TComboBox.Create(panels[pan]);
  comboBox_Member.Parent := panels[pan];
  comboBox_Member.SetBounds(label_Username.left, label_Member.top + label_Member.height + 5, 83, 21);
  comboBox_Member.OnKeyPress := @PreventTyping;
  comboBox_Member.Items.Add('True');
  comboBox_Member.Items.Add('False');
  comboBox_Member.Text := 'False';
  comboBox_Member.Hint := 'Set to True if this player is a member';
  comboBox_Member.ShowHint := True;

  btn_AddPlayer := TButton.Create(panels[pan]);
  btn_AddPlayer.Parent := panels[pan];
  btn_AddPlayer.Setbounds(22,22,95,25);
  btn_AddPlayer.Caption := 'Add Player';
  btn_AddPlayer.OnClick := @PanelOneClicks;
  btn_AddPlayer.Hint := 'Click after you''ve filled out the player''s information on the right';
  btn_AddPlayer.ShowHint := True;

  btn_DeletePlayer := TButton.Create(panels[pan]);
  btn_DeletePlayer.Parent := panels[pan];
  btn_DeletePlayer.SetBounds(btn_AddPlayer.left+btn_AddPlayer.width+10,btn_AddPlayer.top,btn_AddPlayer.width,btn_AddPlayer.height);
  btn_DeletePlayer.Caption := 'Remove Player';
  btn_DeletePlayer.OnClick := @PanelOneClicks;
  btn_DeletePlayer.Enabled := (Length(MSI_Players) > 1);
  btn_DeletePlayer.Hint := 'Deletes the selected player in the box below';
  btn_DeletePlayer.ShowHint := True;

  panOne_Inst := TLabel.Create(panels[pan]);
  panOne_Inst.Parent := panels[pan];
  panOne_Inst.SetBounds(50,3,73,25);
  panOne_Inst.Caption := 'Input player information and click Add Player';
  panOne_Inst.Font.Color := 2070783;

  label_CurPlayer := TLabel.Create(panels[pan]);
  with label_CurPlayer do
  begin
    Parent := panels[pan];
    Height := 25;
    Left := checkList_Players.Left;
    Top := checkList_Players.Top + checkList_Players.Height + 10;
    Width := 85;
    Caption := 'Starting Player';
    Font.Color := 2070783;
  end;

  edit_CurPlayer := TEdit.Create(panels[pan]);
  with edit_CurPlayer do
  begin
    Parent := panels[pan];
    Height := 15;
    Width := 30;
    Left := label_CurPlayer.Left + label_CurPlayer.Width;
    Top := label_CurPlayer.Top - 3;
    Text := '0';
    Hint := '[OPTIONAL] Which player do you want to start with?';
    ShowHint := True;
  end;





  pan := IMG_TAB_NORM_2;

  inst_P3 := TLabel.Create(panels[pan]);
  inst_P3.Parent := panels[pan];
  inst_P3.SetBounds(60,3,73,25);
  inst_P3.Caption := 'Choose a script(s) for each player to use';
  inst_P3.Font.Color := 2070783;

  CheckListBox_3 := TCheckListBox.Create(panels[pan]);
  CheckListBox_3.Parent := panels[pan];
  CheckListBox_3.SetBounds(10, 55, 315, 220);
  CheckListBox_3.Hint := 'Choose a script(s) for each player to use';
  CheckListBox_3.ShowHint := True;
  for i := 0 to High(MSI_Scripts) do
  begin
    if (MSI_Scripts[i].Name = '') then
      Continue;

    CheckListBox_3.Items.Add(Capitalize(MSI_Scripts[i].Name));
  end;

  CheckListBox_3.Enabled := False;




  pan := IMG_TAB_NORM_3;

  CheckListBox_4 := TCheckListBox.Create(panels[pan]);
  CheckListBox_4.Parent := panels[pan];
  CheckListBox_4.SetBounds(10, 55, 315, 220);
  {
  for i := 0 to High(MSI_Locations) do
  begin
    if (MSI_Locations[i].Name = '') or (MSI_Locations[i].Name = 'Lost') then
      Continue;

    CheckListBox_4.Items.Append(Capitalize(MSI_Locations[i].Name));
  end;
  }
  CheckListBox_4.Hint := 'Choose ONE location for each player. Having more than one '+#10+
                         'location checked off may cause the script to fail.';
  CheckListBox_4.ShowHint := True;
  CheckListBox_4.Enabled := False;

  inst_P4 := TLabel.Create(panels[pan]);
  inst_P4.Parent := panels[pan];
  inst_P4.SetBounds(85, 3, 73, 25);
  inst_P4.Caption := 'Set a location for each player';
  inst_P4.Font.Color := 2070783;




  pan := IMG_TAB_NORM_4;

  inst_P5 := TLabel.Create(panels[pan]);
  inst_P5.Parent := panels[pan];
  inst_P5.SetBounds(38, 3, 73, 25);
  inst_P5.Caption := 'Set all other required information for each player';
  inst_P5.Font.Color := 2070783;

  time_Total_5 := TEdit.Create(panels[pan]);
  time_Total_5.Parent := panels[pan];
  time_Total_5.SetBounds(180, 60, 83, 21);
  time_Total_5.Text := '0';
  time_Total_5.Enabled := False;
  time_Total_5.Hint := 'The total time (in minutes) to auto on this character. Set to 0 to run forever.';
  time_Total_5.ShowHint := True;

  loads_Total_5 := TEdit.Create(panels[pan]);
  with loads_Total_5 do
  begin
    Parent := panels[pan];
    SetBounds(time_Total_5.Left, time_Total_5.Top + time_Total_5.Height + 10, 83, 21);
    Text := '0';
    Enabled := False;
    Hint := 'The total loads for this character to do. Set to 0 to run forever.';
    ShowHint := True;
  end;

  time_Break_5 := TEdit.Create(panels[pan]);
  time_Break_5.Parent := panels[pan];
  time_Break_5.SetBounds(time_Total_5.Left, loads_Total_5.Top + loads_Total_5.Height + 10, 83, 21);
  time_Break_5.Text := '0';
  time_Break_5.Enabled := False;
  time_Break_5.Hint := 'How long to auto before breaking (in minutes). '+#10+
                       'Set to 0 if you don''t want to take breaks.';
  time_Break_5.ShowHint := True;

  loads_Break_5 := TEdit.Create(panels[pan]);
  loads_Break_5.Parent := panels[pan];
  loads_Break_5.SetBounds(time_Total_5.Left, time_Break_5.Top + time_Break_5.Height + 10, 83, 21);
  loads_Break_5.Text := '0';
  loads_Break_5.Enabled := False;
  loads_Break_5.Hint := 'How many loads to do before breaking. '+#10+
                        'Set to 0 if you don''t want to take breaks.';
  loads_Break_5.ShowHint := True;

  timeTotal := TLabel.Create(panels[pan]);
  timeTotal.Parent := panels[pan];
  timeTotal.Setbounds(55, 63,32,13);
  timeTotal.Caption := 'Total Time (minutes)';
  timeTotal.Font.Color := 2070783;

  loadsTotal := TLabel.Create(panels[pan]);
  with loadsTotal do
  begin
    Parent := panels[pan];
    Setbounds(timeTotal.Left, timeTotal.Top + time_total_5.height + 10,32,13);
    Caption := 'Total Loads';
    Font.Color := 2070783;
  end;

  timeBreak := TLabel.Create(panels[pan]);
  timeBreak.Parent := panels[pan];
  timeBreak.Setbounds(timeTotal.Left, loadsTotal.Top + loads_total_5.height + 10,32,13);
  timeBreak.Caption := 'Break After (minutes)';
  timeBreak.Font.Color := 2070783;

  loadsBreak := TLabel.Create(panels[pan]);
  loadsBreak.Parent := panels[pan];
  loadsBreak.Setbounds(timeTotal.Left, timeBreak.Top + time_Break_5.Height+10,32,13);
  loadsBreak.Caption := 'Break After (loads)';
  loadsBreak.Font.Color := 2070783;



  pan := IMG_TAB_NORM_5;

  pScript := TButton.Create(panels[pan]);
  pScript.Parent := panels[pan];
  pScript.SetBounds(Previous[pan].Left, Previous[pan].Top + (Previous[pan].Height * 2) + 10, 73, 25);
  pScript.Caption := 'Previous';
  pScript.OnClick := @PanelFiveClicks;
  pScript.Enabled := False;
  pScript.Hint := 'Go to the selected player''s previous script';
  pScript.ShowHint := True;

  ComboBox_Script_6 := TComboBox.Create(panels[pan]);
  ComboBox_Script_6.Parent := panels[pan];
  ComboBox_Script_6.SetBounds(ChoosePlay[pan].left, ChoosePlay[pan].top + (ChoosePlay[pan].height * 2) + 18, 115, 21);
  ComboBox_Script_6.Text := '';
  ComboBox_Script_6.OnChange := @PanelFiveClicks;
  ComboBox_Script_6.OnKeyPress := @PreventTyping;
  ComboBox_Script_6.OnClick := @OnClickEvents;
  ComboBox_Script_6.Hint := 'Choose a script to setup for the selected player';
  ComboBox_Script_6.ShowHint := True;

  nScript := TButton.Create(panels[pan]);
  nScript.Parent := panels[pan];
  nScript.SetBounds(Next[pan].left, Next[pan].top + (Next[pan].height * 2) + 10, 75, 25);
  nScript.Caption := 'Next';
  nScript.OnClick := @PanelFiveClicks;
  nScript.Enabled := False;
  nScript.Hint := 'Go to the selected player''s next script';
  nScript.ShowHint := True;

  for i := 0 to High(five_Labels) do
  begin
    five_Labels[i] := TLabel.Create(panels[pan]);
    with five_Labels[i] do
    begin
      Parent := panels[pan];
      Font.Color := 2070783;
      Height := 20;
      Width := 80;

      case i of
        0: begin
             Top := 3;
             Left := 80;
             SetBounds(80, 3, 73, 25);
             Caption := 'Setup each script for each player';
           end;

        1: begin
             Left := Previous[IMG_TAB_NORM_5].Left;
             Top := Previous[IMG_TAB_NORM_5].Top - (Height);
             Caption := 'Choose a player';
           end;

        2: begin
             Left := pScript.Left;
             Top := pScript.Top - (Height);
             Caption := 'Choose a script for selected player';
           end;
      end;
    end;
  end;

  intro_CreateComponents;
  intro_Settings(False);

  if (FileExists(PATH_PLAYER)) then
  begin
    DrawBitmap(frmBitmaps[LOAD_TAB_NORM],tImages[IMG_LOAD_TAB_NORM].Canvas, 0, 0);
    LoadPlayers;
  end;

  MainForm.ShowModal;
end;

procedure ThreadSafeCallEx(Proc: string);
var
  V: TVariantArray;
begin
  SetLength(V, 0);
  ThreadSafeCall(Proc, V);
end;

procedure FreeMSIForm;
begin
  AnimTimer.Enabled := False;
  AnimTimer.Free;
  script_Form.Free;
  MainForm.Free;
end;
